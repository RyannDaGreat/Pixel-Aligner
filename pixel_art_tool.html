<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Alignment Tool</title>
    <script src="https://code.iconify.design/3/3.1.0/iconify.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .controls {
            padding: 15px 20px;
            background: #16213e;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #0f3460;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-size: 14px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 200px;
            cursor: pointer;
        }
        .control-group span {
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }
        .opacity-buttons {
            display: flex;
            gap: 5px;
        }
        .opacity-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .opacity-btn:hover {
            background: #1a4a7a;
        }
        .opacity-btn.active, .sample-btn.active {
            background: #e94560;
            color: white;
        }
        .sample-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .sample-btn:hover {
            background: #1a4a7a;
        }
        .icon-btn {
            background: #0f3460;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 6px 10px;
            color: #888;
            transition: all 0.2s;
            font-size: 16px;
        }
        .icon-btn:hover {
            background: #1a4a7a;
        }
        .icon-btn.active {
            color: #e94560;
        }
        .reset-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .reset-btn:hover {
            background: #e94560;
        }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-pair {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .chain-btn {
            background: #0f3460;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 4px 8px;
            color: #888;
            transition: all 0.2s;
            font-size: 14px;
            align-self: center;
        }
        .chain-btn:hover {
            background: #1a4a7a;
        }
        .chain-btn.active {
            color: #e94560;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mainCanvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(26, 26, 46, 0.9);
            border: 3px dashed #e94560;
            margin: 20px;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .drop-zone.active {
            opacity: 1;
        }
        .drop-zone.show-initial {
            opacity: 1;
            pointer-events: auto;
        }
        .drop-zone p {
            font-size: 24px;
            color: #e94560;
        }
        .instructions {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group slider-group">
            <div class="slider-pair">
                <div class="control-group">
                    <label style="width: 60px;">N (cols):</label>
                    <input type="range" id="nSlider" min="1" max="128" value="16">
                    <input type="number" id="nInput" min="1" value="16" style="width: 50px; background: #0f3460; border: none; color: #e94560; padding: 4px; border-radius: 4px; text-align: center;">
                </div>
                <div class="control-group">
                    <label style="width: 60px;">M (rows):</label>
                    <input type="range" id="mSlider" min="1" max="128" value="16">
                    <input type="number" id="mInput" min="1" value="16" style="width: 50px; background: #0f3460; border: none; color: #e94560; padding: 4px; border-radius: 4px; text-align: center;">
                </div>
            </div>
            <button class="chain-btn active" id="resolutionLock" title="Lock N:M ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Aspect:</label>
            <button class="icon-btn active" id="aspectLock" title="Lock rectangle aspect ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Grid Opacity:</label>
            <div class="opacity-buttons">
                <button class="opacity-btn" data-opacity="0">0%</button>
                <button class="opacity-btn active" data-opacity="50">50%</button>
                <button class="opacity-btn" data-opacity="100">100%</button>
            </div>
        </div>
        <div class="control-group">
            <label>Sample:</label>
            <div class="opacity-buttons">
                <button class="sample-btn active" data-sample="center">Center</button>
                <button class="sample-btn" data-sample="mean">Mean</button>
                <button class="sample-btn" data-sample="median">Median</button>
            </div>
        </div>
        <div class="control-group">
            <label>Expand:</label>
            <button class="icon-btn" id="expandMode" title="Expand mode: resize by adding/removing cells">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="currentColor">
                    <rect x="1" y="1" width="5" height="5" rx="1"/>
                    <rect x="7" y="1" width="5" height="5" rx="1"/>
                    <rect x="1" y="7" width="5" height="5" rx="1"/>
                    <rect x="7" y="7" width="5" height="5" rx="1" opacity="0.4"/>
                    <rect x="13" y="7" width="4" height="5" rx="1" opacity="0.4"/>
                    <rect x="7" y="13" width="5" height="4" rx="1" opacity="0.4"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <span class="iconify" data-icon="mdi:undo" data-width="20"></span>
            </button>
            <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <span class="iconify" data-icon="mdi:redo" data-width="20"></span>
            </button>
        </div>
        <div class="control-group">
            <button class="reset-btn" id="resetBtn">Reset Grid</button>
        </div>
        <div class="control-group">
            <button class="reset-btn" id="saveBtn" style="background: #e94560;">Save PNG</button>
        </div>
        <div class="control-group">
            <input type="text" id="infoField" readonly style="background: #0f3460; border: none; color: #e94560; padding: 6px 10px; border-radius: 4px; font-family: monospace; font-size: 12px; width: 320px; cursor: pointer;" title="Click to copy">
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <canvas id="mainCanvas"></canvas>
        <div class="drop-zone show-initial" id="dropZone">
            <p>Drop an image here</p>
        </div>
    </div>

    <div class="instructions">
        Drag corners to resize the pixel grid. Drag inside to move it. Use sliders to change grid dimensions.
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const dropZone = document.getElementById('dropZone');
        const nSlider = document.getElementById('nSlider');
        const mSlider = document.getElementById('mSlider');
        const nInput = document.getElementById('nInput');
        const mInput = document.getElementById('mInput');
        const aspectLockBtn = document.getElementById('aspectLock');
        const resolutionLockBtn = document.getElementById('resolutionLock');
        const resetBtn = document.getElementById('resetBtn');
        const expandModeBtn = document.getElementById('expandMode');
        const saveBtn = document.getElementById('saveBtn');
        const infoField = document.getElementById('infoField');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        let image = null;
        let gridOpacity = 0.5;
        let sampleMode = 'center'; // 'center', 'mean', 'median'
        let rect = { x: 100, y: 100, width: 200, height: 200 };
        let dragging = null; // 'move', 'tl', 'tr', 'bl', 'br', 'left', 'right', 'top', 'bottom'
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, width: 0, height: 0 };
        let nStart = 16, mStart = 16; // For expand mode

        // Undo/redo stacks
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO = 50;

        // Lock states
        let aspectLocked = true;
        let lockedAspectRatio = 1; // width / height when locked
        let resolutionLocked = true;
        let expandModeOn = false;

        const defaultRect = { x: 100, y: 100, width: 200, height: 200 };
        const defaultN = 16;
        const defaultM = 16;

        function getInfoString() {
            const n = parseInt(nSlider.value);
            const m = parseInt(mSlider.value);
            return `x=${rect.x.toFixed(1)} y=${rect.y.toFixed(1)} w=${rect.width.toFixed(1)} h=${rect.height.toFixed(1)} n=${n} m=${m}`;
        }

        function updateInfoField() {
            infoField.value = getInfoString();
        }

        function updateSliderMax(n, m) {
            if (n > parseInt(nSlider.max)) nSlider.max = n;
            if (m > parseInt(mSlider.max)) mSlider.max = m;
        }

        function getState() {
            return {
                rect: { ...rect },
                n: parseInt(nSlider.value),
                m: parseInt(mSlider.value)
            };
        }

        function setState(state) {
            rect = { ...state.rect };
            nSlider.value = state.n;
            mSlider.value = state.m;
            nInput.value = state.n;
            mInput.value = state.m;
            render();
        }

        function saveState() {
            undoStack.push(getState());
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack = [];
        }

        function undo() {
            if (undoStack.length === 0) return;
            redoStack.push(getState());
            setState(undoStack.pop());
        }

        function redo() {
            if (redoStack.length === 0) return;
            undoStack.push(getState());
            setState(redoStack.pop());
        }

        // LocalStorage persistence
        function getFullState() {
            return {
                rect: { ...rect },
                n: parseInt(nSlider.value),
                m: parseInt(mSlider.value),
                gridOpacity,
                sampleMode,
                aspectLocked,
                lockedAspectRatio,
                resolutionLocked,
                expandModeOn,
                nMax: parseInt(nSlider.max),
                mMax: parseInt(mSlider.max)
            };
        }

        function setFullState(state) {
            rect = { ...state.rect };
            nSlider.max = state.nMax || 128;
            mSlider.max = state.mMax || 128;
            nSlider.value = state.n;
            mSlider.value = state.m;
            nInput.value = state.n;
            mInput.value = state.m;
            gridOpacity = state.gridOpacity;
            sampleMode = state.sampleMode;
            aspectLocked = state.aspectLocked;
            lockedAspectRatio = state.lockedAspectRatio;
            resolutionLocked = state.resolutionLocked;
            expandModeOn = state.expandModeOn;

            // Update UI to match state
            document.querySelectorAll('.opacity-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.opacity-btn[data-opacity="${Math.round(gridOpacity * 100)}"]`)?.classList.add('active');

            document.querySelectorAll('.sample-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.sample-btn[data-sample="${sampleMode}"]`)?.classList.add('active');

            aspectLockBtn.classList.toggle('active', aspectLocked);
            updateLockIcon(aspectLockBtn, aspectLocked);

            resolutionLockBtn.classList.toggle('active', resolutionLocked);
            updateLockIcon(resolutionLockBtn, resolutionLocked);

            expandModeBtn.classList.toggle('active', expandModeOn);
        }

        function saveToLocalStorage() {
            const state = getFullState();
            localStorage.setItem('pixelArtToolState', JSON.stringify(state));

            // Save image as data URL
            if (image) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(image, 0, 0);
                localStorage.setItem('pixelArtToolImage', tempCanvas.toDataURL('image/png'));
            }
        }

        function loadFromLocalStorage() {
            const stateJson = localStorage.getItem('pixelArtToolState');
            const imageData = localStorage.getItem('pixelArtToolImage');

            if (imageData) {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    resizeCanvas();
                    dropZone.classList.remove('show-initial');

                    if (stateJson) {
                        setFullState(JSON.parse(stateJson));
                    }
                    render();
                };
                img.src = imageData;
            } else if (stateJson) {
                setFullState(JSON.parse(stateJson));
            }
        }

        // Auto-save on changes
        function autoSave() {
            saveToLocalStorage();
        }

        function sampleCell(imgData, x0, y0, x1, y1, width) {
            // Clamp bounds
            x0 = Math.max(0, Math.floor(x0));
            y0 = Math.max(0, Math.floor(y0));
            x1 = Math.min(width, Math.floor(x1));
            y1 = Math.min(imgData.height, Math.floor(y1));

            if (x1 <= x0 || y1 <= y0) return null;

            const pixels = [];
            for (let y = y0; y < y1; y++) {
                for (let x = x0; x < x1; x++) {
                    const idx = (y * width + x) * 4;
                    pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                }
            }

            if (pixels.length === 0) return null;

            if (sampleMode === 'center') {
                const cx = Math.floor((x0 + x1) / 2);
                const cy = Math.floor((y0 + y1) / 2);
                const idx = (cy * width + cx) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            } else if (sampleMode === 'mean') {
                const sum = [0, 0, 0];
                for (const p of pixels) {
                    sum[0] += p[0];
                    sum[1] += p[1];
                    sum[2] += p[2];
                }
                return [sum[0] / pixels.length, sum[1] / pixels.length, sum[2] / pixels.length];
            } else if (sampleMode === 'median') {
                const r = pixels.map(p => p[0]).sort((a, b) => a - b);
                const g = pixels.map(p => p[1]).sort((a, b) => a - b);
                const b = pixels.map(p => p[2]).sort((a, b) => a - b);
                const mid = Math.floor(pixels.length / 2);
                return [r[mid], g[mid], b[mid]];
            }
            return null;
        }

        // Click to copy
        infoField.addEventListener('click', () => {
            infoField.select();
            navigator.clipboard.writeText(infoField.value);
        });

        // Undo/redo buttons
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // Opacity buttons
        document.querySelectorAll('.opacity-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.opacity-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gridOpacity = parseInt(btn.dataset.opacity) / 100;
                render();
                autoSave();
            });
        });

        // Sample mode buttons
        document.querySelectorAll('.sample-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.sample-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                sampleMode = btn.dataset.sample;
                render();
                autoSave();
            });
        });

        // Aspect lock toggle
        aspectLockBtn.addEventListener('click', () => {
            aspectLocked = !aspectLocked;
            aspectLockBtn.classList.toggle('active', aspectLocked);
            if (aspectLocked) {
                lockedAspectRatio = rect.width / rect.height;
            }
            updateLockIcon(aspectLockBtn, aspectLocked);
            autoSave();
        });

        // Resolution lock toggle
        resolutionLockBtn.addEventListener('click', () => {
            resolutionLocked = !resolutionLocked;
            resolutionLockBtn.classList.toggle('active', resolutionLocked);
            updateLockIcon(resolutionLockBtn, resolutionLocked);
            autoSave();
        });

        function updateLockIcon(btn, locked) {
            const svg = btn.querySelector('svg');
            if (locked) {
                svg.innerHTML = `
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                `;
            } else {
                svg.innerHTML = `
                    <path d="M12 8h-2V6a2 2 0 10-4 0v2H4V6a4 4 0 118 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                `;
            }
        }

        // Expand mode toggle
        expandModeBtn.addEventListener('click', () => {
            expandModeOn = !expandModeOn;
            expandModeBtn.classList.toggle('active', expandModeOn);
            autoSave();
        });

        // Save PNG button
        saveBtn.addEventListener('click', () => {
            if (!image) return;

            const n = parseInt(nSlider.value);
            const m = parseInt(mSlider.value);

            // Create low-res canvas (1 pixel per cell)
            const outCanvas = document.createElement('canvas');
            outCanvas.width = n;
            outCanvas.height = m;
            const outCtx = outCanvas.getContext('2d');

            // Draw original image to a temp canvas at full res for sampling
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0, canvas.width, canvas.height);

            const cellW = rect.width / n;
            const cellH = rect.height / m;

            // Get full image data for sampling
            const imgData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < m; row++) {
                for (let col = 0; col < n; col++) {
                    const cellX = rect.x + col * cellW;
                    const cellY = rect.y + row * cellH;

                    const color = sampleCell(imgData, cellX, cellY, cellX + cellW, cellY + cellH, canvas.width);
                    if (color) {
                        outCtx.fillStyle = `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
                        outCtx.fillRect(col, row, 1, 1);
                    }
                }
            }

            // Download with info in filename
            const link = document.createElement('a');
            const filename = `pixel_art_x${rect.x.toFixed(0)}_y${rect.y.toFixed(0)}_w${rect.width.toFixed(0)}_h${rect.height.toFixed(0)}_n${n}_m${m}.png`;
            link.download = filename;
            link.href = outCanvas.toDataURL('image/png');
            link.click();
        });

        // Reset button
        resetBtn.addEventListener('click', () => {
            nSlider.value = defaultN;
            mSlider.value = defaultM;
            nInput.value = defaultN;
            mInput.value = defaultM;
            if (image) {
                rect.width = defaultRect.width;
                rect.height = defaultRect.height;
                rect.x = (canvas.width - rect.width) / 2;
                rect.y = (canvas.height - rect.height) / 2;
            } else {
                rect = { ...defaultRect };
            }
            aspectLocked = false;
            aspectLockBtn.classList.remove('active');
            updateLockIcon(aspectLockBtn, false);
            lockedAspectRatio = 1;
            render();
            autoSave();
        });

        // Sliders
        nSlider.addEventListener('input', () => {
            const newN = parseInt(nSlider.value);
            nInput.value = newN;
            if (resolutionLocked) {
                mSlider.value = newN;
                mInput.value = newN;
            }
            render();
            autoSave();
        });
        mSlider.addEventListener('input', () => {
            const newM = parseInt(mSlider.value);
            mInput.value = newM;
            if (resolutionLocked) {
                nSlider.value = newM;
                nInput.value = newM;
            }
            render();
            autoSave();
        });

        // Number inputs
        nInput.addEventListener('input', () => {
            const newN = Math.max(1, parseInt(nInput.value) || 1);
            updateSliderMax(newN, parseInt(mSlider.value));
            nSlider.value = newN;
            nInput.value = newN;
            if (resolutionLocked) {
                updateSliderMax(newN, newN);
                mSlider.value = newN;
                mInput.value = newN;
            }
            render();
            autoSave();
        });
        mInput.addEventListener('input', () => {
            const newM = Math.max(1, parseInt(mInput.value) || 1);
            updateSliderMax(parseInt(nSlider.value), newM);
            mSlider.value = newM;
            mInput.value = newM;
            if (resolutionLocked) {
                updateSliderMax(newM, newM);
                nSlider.value = newM;
                nInput.value = newM;
            }
            render();
            autoSave();
        });

        // Drag and drop
        container.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.classList.add('active');
        });
        container.addEventListener('dragleave', e => {
            if (!container.contains(e.relatedTarget)) {
                dropZone.classList.remove('active');
            }
        });
        container.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.classList.remove('active');
            dropZone.classList.remove('show-initial');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    resizeCanvas();

                    // Adapt grid to image - cover most of the canvas
                    const padding = 20;
                    rect.width = canvas.width - padding * 2;
                    rect.height = canvas.height - padding * 2;
                    rect.x = padding;
                    rect.y = padding;

                    // Update aspect ratio if locked
                    if (aspectLocked) {
                        lockedAspectRatio = rect.width / rect.height;
                    }

                    // Set N/M based on image aspect ratio, default ~16 for shorter dimension
                    const baseSize = 16;
                    if (image.width >= image.height) {
                        const m = baseSize;
                        const n = Math.round(baseSize * (image.width / image.height));
                        nSlider.value = Math.min(128, Math.max(2, n));
                        mSlider.value = m;
                    } else {
                        const n = baseSize;
                        const m = Math.round(baseSize * (image.height / image.width));
                        nSlider.value = n;
                        mSlider.value = Math.min(128, Math.max(2, m));
                    }
                    nInput.value = nSlider.value;
                    mInput.value = mSlider.value;

                    render();
                    autoSave();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvas() {
            if (!image) return;
            // Keep canvas at full resolution
            canvas.width = image.width;
            canvas.height = image.height;

            // Scale display via CSS to fit container
            const containerRect = container.getBoundingClientRect();
            const maxW = containerRect.width - 40;
            const maxH = containerRect.height - 40;
            const displayScale = Math.min(maxW / image.width, maxH / image.height, 1);
            canvas.style.width = (image.width * displayScale) + 'px';
            canvas.style.height = (image.height * displayScale) + 'px';
        }

        function render() {
            if (!image) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the original image
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

            const n = parseInt(nSlider.value);
            const m = parseInt(mSlider.value);
            const cellW = rect.width / n;
            const cellH = rect.height / m;

            // Draw pixelated version inside the rectangle
            if (gridOpacity > 0) {
                // Get full image data once for efficient sampling
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.globalAlpha = gridOpacity;

                // Sample and draw each pixel cell
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const cellX = rect.x + col * cellW;
                        const cellY = rect.y + row * cellH;

                        // Skip if cell is outside canvas
                        if (cellX + cellW < 0 || cellX > canvas.width ||
                            cellY + cellH < 0 || cellY > canvas.height) continue;

                        const color = sampleCell(imgData, cellX, cellY, cellX + cellW, cellY + cellH, canvas.width);
                        if (color) {
                            ctx.fillStyle = `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
                            ctx.fillRect(cellX, cellY, cellW + 0.5, cellH + 0.5);
                        }
                    }
                }
                ctx.restore();
            }

            // Draw grid lines - scale line width based on display
            const gridCanvasRect = canvas.getBoundingClientRect();
            const gridScale = canvas.width / gridCanvasRect.width;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1 * gridScale;
            ctx.beginPath();
            for (let i = 0; i <= n; i++) {
                const x = rect.x + i * cellW;
                ctx.moveTo(x, rect.y);
                ctx.lineTo(x, rect.y + rect.height);
            }
            for (let i = 0; i <= m; i++) {
                const y = rect.y + i * cellH;
                ctx.moveTo(rect.x, y);
                ctx.lineTo(rect.x + rect.width, y);
            }
            ctx.stroke();

            // Draw rectangle border
            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 2 * gridScale;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

            // Draw corner handles - scale based on display size
            const canvasRect = canvas.getBoundingClientRect();
            const displayScale = canvas.width / canvasRect.width;
            const handleSize = 10 * displayScale;
            ctx.fillStyle = '#e94560';
            const corners = [
                { x: rect.x, y: rect.y },
                { x: rect.x + rect.width, y: rect.y },
                { x: rect.x, y: rect.y + rect.height },
                { x: rect.x + rect.width, y: rect.y + rect.height }
            ];
            corners.forEach(c => {
                ctx.fillRect(c.x - handleSize/2, c.y - handleSize/2, handleSize, handleSize);
            });

            updateInfoField();
        }

        function getMousePos(e) {
            const canvasRect = canvas.getBoundingClientRect();
            // Account for CSS scaling
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;
            return {
                x: (e.clientX - canvasRect.left) * scaleX,
                y: (e.clientY - canvasRect.top) * scaleY
            };
        }

        function getHitZone(pos) {
            // Scale handle size based on canvas display scale
            const canvasRect = canvas.getBoundingClientRect();
            const scale = canvas.width / canvasRect.width;
            const handleSize = 15 * scale;

            // Check corners first
            const corners = [
                { x: rect.x, y: rect.y, id: 'tl' },
                { x: rect.x + rect.width, y: rect.y, id: 'tr' },
                { x: rect.x, y: rect.y + rect.height, id: 'bl' },
                { x: rect.x + rect.width, y: rect.y + rect.height, id: 'br' }
            ];

            for (const c of corners) {
                if (Math.abs(pos.x - c.x) < handleSize && Math.abs(pos.y - c.y) < handleSize) {
                    return c.id;
                }
            }

            // Check edges
            const onLeft = Math.abs(pos.x - rect.x) < handleSize && pos.y > rect.y && pos.y < rect.y + rect.height;
            const onRight = Math.abs(pos.x - (rect.x + rect.width)) < handleSize && pos.y > rect.y && pos.y < rect.y + rect.height;
            const onTop = Math.abs(pos.y - rect.y) < handleSize && pos.x > rect.x && pos.x < rect.x + rect.width;
            const onBottom = Math.abs(pos.y - (rect.y + rect.height)) < handleSize && pos.x > rect.x && pos.x < rect.x + rect.width;

            if (onLeft) return 'left';
            if (onRight) return 'right';
            if (onTop) return 'top';
            if (onBottom) return 'bottom';

            if (pos.x >= rect.x && pos.x <= rect.x + rect.width &&
                pos.y >= rect.y && pos.y <= rect.y + rect.height) {
                return 'move';
            }

            return null;
        }

        canvas.addEventListener('mousedown', e => {
            const pos = getMousePos(e);
            dragging = getHitZone(pos);
            if (dragging) {
                saveState(); // Save state for undo
                dragStart = pos;
                rectStart = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
                nStart = parseInt(nSlider.value);
                mStart = parseInt(mSlider.value);
            }
        });

        canvas.addEventListener('mousemove', e => {
            const pos = getMousePos(e);

            // Update cursor
            const zone = getHitZone(pos);
            if (zone === 'tl' || zone === 'br') canvas.style.cursor = 'nwse-resize';
            else if (zone === 'tr' || zone === 'bl') canvas.style.cursor = 'nesw-resize';
            else if (zone === 'left' || zone === 'right') canvas.style.cursor = 'ew-resize';
            else if (zone === 'top' || zone === 'bottom') canvas.style.cursor = 'ns-resize';
            else if (zone === 'move') canvas.style.cursor = 'move';
            else canvas.style.cursor = 'default';

            if (!dragging) return;

            let dx = pos.x - dragStart.x;
            let dy = pos.y - dragStart.y;

            // Shift key = 10x precision (slow down) always
            const shiftPressed = e.shiftKey;
            if (shiftPressed) {
                dx /= 10;
                dy /= 10;
            }

            // Control key = snap to axis (whichever has more movement)
            if (e.ctrlKey || e.metaKey) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    dy = 0;
                } else {
                    dx = 0;
                }
            }

            if (dragging === 'move') {
                let newX = rectStart.x + dx;
                let newY = rectStart.y + dy;

                // In expand mode, snap to pixel grid unless shift is pressed
                if (expandModeOn && !shiftPressed) {
                    const cellW = rect.width / parseInt(nSlider.value);
                    const cellH = rect.height / parseInt(mSlider.value);
                    newX = Math.round(newX / cellW) * cellW;
                    newY = Math.round(newY / cellH) * cellH;
                }

                rect.x = newX;
                rect.y = newY;
            } else if (expandModeOn) {
                // Expand mode: add/remove cells, keep cell size fixed
                const cellW = rectStart.width / nStart;
                const cellH = rectStart.height / mStart;

                // Calculate cell deltas
                const cellDx = Math.round(dx / cellW);
                const cellDy = Math.round(dy / cellH);

                if (dragging === 'br') {
                    const newN = Math.max(1, nStart + cellDx);
                    const newM = Math.max(1, mStart + cellDy);
                    rect.width = newN * cellW;
                    rect.height = newM * cellH;
                    updateSliderMax(newN, newM);
                    nSlider.value = newN; nInput.value = newN;
                    mSlider.value = newM; mInput.value = newM;
                } else if (dragging === 'tl') {
                    const newN = Math.max(1, nStart - cellDx);
                    const newM = Math.max(1, mStart - cellDy);
                    rect.x = rectStart.x + (nStart - newN) * cellW;
                    rect.y = rectStart.y + (mStart - newM) * cellH;
                    rect.width = newN * cellW;
                    rect.height = newM * cellH;
                    updateSliderMax(newN, newM);
                    nSlider.value = newN; nInput.value = newN;
                    mSlider.value = newM; mInput.value = newM;
                } else if (dragging === 'tr') {
                    const newN = Math.max(1, nStart + cellDx);
                    const newM = Math.max(1, mStart - cellDy);
                    rect.y = rectStart.y + (mStart - newM) * cellH;
                    rect.width = newN * cellW;
                    rect.height = newM * cellH;
                    updateSliderMax(newN, newM);
                    nSlider.value = newN; nInput.value = newN;
                    mSlider.value = newM; mInput.value = newM;
                } else if (dragging === 'bl') {
                    const newN = Math.max(1, nStart - cellDx);
                    const newM = Math.max(1, mStart + cellDy);
                    rect.x = rectStart.x + (nStart - newN) * cellW;
                    rect.width = newN * cellW;
                    rect.height = newM * cellH;
                    updateSliderMax(newN, newM);
                    nSlider.value = newN; nInput.value = newN;
                    mSlider.value = newM; mInput.value = newM;
                } else if (dragging === 'left') {
                    const newN = Math.max(1, nStart - cellDx);
                    rect.x = rectStart.x + (nStart - newN) * cellW;
                    rect.width = newN * cellW;
                    updateSliderMax(newN, mStart);
                    nSlider.value = newN; nInput.value = newN;
                } else if (dragging === 'right') {
                    const newN = Math.max(1, nStart + cellDx);
                    rect.width = newN * cellW;
                    updateSliderMax(newN, mStart);
                    nSlider.value = newN; nInput.value = newN;
                } else if (dragging === 'top') {
                    const newM = Math.max(1, mStart - cellDy);
                    rect.y = rectStart.y + (mStart - newM) * cellH;
                    rect.height = newM * cellH;
                    updateSliderMax(nStart, newM);
                    mSlider.value = newM; mInput.value = newM;
                } else if (dragging === 'bottom') {
                    const newM = Math.max(1, mStart + cellDy);
                    rect.height = newM * cellH;
                    updateSliderMax(nStart, newM);
                    mSlider.value = newM; mInput.value = newM;
                }
            } else {
                // Corner dragging with aspect ratio support
                if (aspectLocked) {
                    // When aspect locked, scale uniformly based on larger delta
                    const scaleFactor = Math.max(Math.abs(dx) / rectStart.width, Math.abs(dy) / rectStart.height);

                    if (dragging === 'br') {
                        const sign = (dx + dy) > 0 ? 1 : -1;
                        const newWidth = Math.max(20, rectStart.width * (1 + sign * scaleFactor));
                        const newHeight = newWidth / lockedAspectRatio;
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'tl') {
                        const sign = (dx + dy) > 0 ? -1 : 1;
                        const newWidth = Math.max(20, rectStart.width * (1 + sign * scaleFactor));
                        const newHeight = newWidth / lockedAspectRatio;
                        rect.x = rectStart.x + (rectStart.width - newWidth);
                        rect.y = rectStart.y + (rectStart.height - newHeight);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'tr') {
                        const sign = (dx - dy) > 0 ? 1 : -1;
                        const newWidth = Math.max(20, rectStart.width * (1 + sign * scaleFactor));
                        const newHeight = newWidth / lockedAspectRatio;
                        rect.y = rectStart.y + (rectStart.height - newHeight);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'bl') {
                        const sign = (-dx + dy) > 0 ? 1 : -1;
                        const newWidth = Math.max(20, rectStart.width * (1 + sign * scaleFactor));
                        const newHeight = newWidth / lockedAspectRatio;
                        rect.x = rectStart.x + (rectStart.width - newWidth);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'left') {
                        // Scale from center of right edge
                        const newWidth = Math.max(20, rectStart.width - dx);
                        const newHeight = newWidth / lockedAspectRatio;
                        const rightEdgeCenterY = rectStart.y + rectStart.height / 2;
                        rect.x = rectStart.x + rectStart.width - newWidth;
                        rect.y = rightEdgeCenterY - newHeight / 2;
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'right') {
                        // Scale from center of left edge
                        const newWidth = Math.max(20, rectStart.width + dx);
                        const newHeight = newWidth / lockedAspectRatio;
                        const leftEdgeCenterY = rectStart.y + rectStart.height / 2;
                        rect.y = leftEdgeCenterY - newHeight / 2;
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'top') {
                        // Scale from center of bottom edge
                        const newHeight = Math.max(20, rectStart.height - dy);
                        const newWidth = newHeight * lockedAspectRatio;
                        const bottomEdgeCenterX = rectStart.x + rectStart.width / 2;
                        rect.x = bottomEdgeCenterX - newWidth / 2;
                        rect.y = rectStart.y + rectStart.height - newHeight;
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'bottom') {
                        // Scale from center of top edge
                        const newHeight = Math.max(20, rectStart.height + dy);
                        const newWidth = newHeight * lockedAspectRatio;
                        const topEdgeCenterX = rectStart.x + rectStart.width / 2;
                        rect.x = topEdgeCenterX - newWidth / 2;
                        rect.width = newWidth;
                        rect.height = newHeight;
                    }
                } else {
                    // Free resize - width and height independent
                    if (dragging === 'br') {
                        rect.width = Math.max(20, rectStart.width + dx);
                        rect.height = Math.max(20, rectStart.height + dy);
                    } else if (dragging === 'tl') {
                        const newWidth = Math.max(20, rectStart.width - dx);
                        const newHeight = Math.max(20, rectStart.height - dy);
                        rect.x = rectStart.x + (rectStart.width - newWidth);
                        rect.y = rectStart.y + (rectStart.height - newHeight);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'tr') {
                        const newWidth = Math.max(20, rectStart.width + dx);
                        const newHeight = Math.max(20, rectStart.height - dy);
                        rect.y = rectStart.y + (rectStart.height - newHeight);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'bl') {
                        const newWidth = Math.max(20, rectStart.width - dx);
                        const newHeight = Math.max(20, rectStart.height + dy);
                        rect.x = rectStart.x + (rectStart.width - newWidth);
                        rect.width = newWidth;
                        rect.height = newHeight;
                    } else if (dragging === 'left') {
                        const newWidth = Math.max(20, rectStart.width - dx);
                        rect.x = rectStart.x + (rectStart.width - newWidth);
                        rect.width = newWidth;
                    } else if (dragging === 'right') {
                        rect.width = Math.max(20, rectStart.width + dx);
                    } else if (dragging === 'top') {
                        const newHeight = Math.max(20, rectStart.height - dy);
                        rect.y = rectStart.y + (rectStart.height - newHeight);
                        rect.height = newHeight;
                    } else if (dragging === 'bottom') {
                        rect.height = Math.max(20, rectStart.height + dy);
                    }
                }
            }
            render();
        });

        canvas.addEventListener('mouseup', () => {
            if (dragging) autoSave();
            dragging = null;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
        });

        window.addEventListener('resize', () => {
            if (image) {
                resizeCanvas();
                render();
            }
        });

        // Keyboard shortcuts: 1, 2, 3 for opacity, s for save, x for expand, ctrl+z/y for undo/redo
        window.addEventListener('keydown', e => {
            if (e.key === '1' || e.key === '2' || e.key === '3') {
                const opacityMap = { '1': 0, '2': 50, '3': 100 };
                const opacity = opacityMap[e.key];
                document.querySelectorAll('.opacity-btn').forEach(b => b.classList.remove('active'));
                document.querySelector(`.opacity-btn[data-opacity="${opacity}"]`).classList.add('active');
                gridOpacity = opacity / 100;
                render();
                autoSave();
            } else if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                saveBtn.click();
            } else if (e.key === 'x' || e.key === 'X') {
                expandModeBtn.click();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // Load saved state on page load
        loadFromLocalStorage();
    </script>
</body>
</html>

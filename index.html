<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Alignment Tool</title>
    <script src="https://code.iconify.design/3/3.1.0/iconify.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .controls {
            padding: 15px 20px;
            background: #16213e;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #0f3460;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label { font-size: 14px; color: #aaa; }
        .control-group input[type="range"] { width: 200px; cursor: pointer; }
        .btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .btn:hover { background: #1a4a7a; }
        .btn.active { background: #e94560; color: white; }
        .btn.accent { background: #e94560; }
        .icon-btn {
            background: #0f3460;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 6px 10px;
            color: #888;
            transition: all 0.2s;
            font-size: 16px;
        }
        .icon-btn:hover { background: #1a4a7a; }
        .icon-btn.active { color: #e94560; }
        .btn-group { display: flex; gap: 5px; }
        .slider-group { display: flex; align-items: center; gap: 8px; }
        .slider-pair { display: flex; flex-direction: column; gap: 6px; }
        .num-input {
            width: 50px;
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 4px;
            border-radius: 4px;
            text-align: center;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mainCanvas { max-width: 100%; max-height: 100%; display: block; }
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(26, 26, 46, 0.9);
            border: 3px dashed #e94560;
            margin: 20px;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .drop-zone.active, .drop-zone.show-initial { opacity: 1; }
        .drop-zone.show-initial { pointer-events: auto; }
        .drop-zone p { font-size: 24px; color: #e94560; }
        .instructions {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            max-width: 300px;
        }
        #infoField {
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 320px;
            cursor: pointer;
        }
        .chroma-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 4px;
        }
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid #888;
            cursor: pointer;
            background: conic-gradient(#808080 25%, #fff 25% 50%, #808080 50% 75%, #fff 75%);
            background-size: 8px 8px;
        }
        .color-swatch-inner {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }
        .color-picker-hidden {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }
        .chroma-slider {
            width: 80px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group slider-group">
            <div class="slider-pair">
                <div class="control-group">
                    <label style="width: 60px;">N (cols):</label>
                    <input type="range" id="nSlider" min="1" max="500" value="16">
                    <input type="number" id="nInput" min="1" max="500" value="16" class="num-input">
                </div>
                <div class="control-group">
                    <label style="width: 60px;">M (rows):</label>
                    <input type="range" id="mSlider" min="1" max="500" value="16">
                    <input type="number" id="mInput" min="1" max="500" value="16" class="num-input">
                </div>
            </div>
            <button class="icon-btn active" id="resolutionLock" title="Lock N:M ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Aspect:</label>
            <button class="icon-btn active" id="aspectLock" title="Lock rectangle aspect ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Grid Opacity:</label>
            <div class="btn-group" id="opacityBtns">
                <button class="btn" data-value="0">0%</button>
                <button class="btn active" data-value="50">50%</button>
                <button class="btn" data-value="100">100%</button>
            </div>
        </div>
        <div class="control-group">
            <label>Sample:</label>
            <div class="btn-group" id="sampleBtns">
                <button class="btn active" data-value="center">Center</button>
                <button class="btn" data-value="mean">Mean</button>
                <button class="btn" data-value="median">Median</button>
            </div>
        </div>
        <div class="control-group">
            <label>Expand:</label>
            <button class="icon-btn" id="expandMode" title="Expand mode: resize by adding/removing cells">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="currentColor">
                    <rect x="1" y="1" width="5" height="5" rx="1"/>
                    <rect x="7" y="1" width="5" height="5" rx="1"/>
                    <rect x="1" y="7" width="5" height="5" rx="1"/>
                    <rect x="7" y="7" width="5" height="5" rx="1" opacity="0.4"/>
                    <rect x="13" y="7" width="4" height="5" rx="1" opacity="0.4"/>
                    <rect x="7" y="13" width="5" height="4" rx="1" opacity="0.4"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Tiles:</label>
            <div class="btn-group" id="tileBtns">
                <button class="btn active" data-value="square" title="Square tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><rect x="1" y="1" width="12" height="12"/></svg>
                </button>
                <button class="btn" data-value="hex" title="Flat-top hexagon (H)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M4 1H10L13 7L10 13H4L1 7L4 1Z"/></svg>
                </button>
                <button class="btn" data-value="hexV" title="Pointy-top hexagon">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 0.5L13 4V10L7 13.5L1 10V4L7 0.5Z"/></svg>
                </button>
                <button class="btn" data-value="tri" title="Triangle tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 1L13 13H1L7 1Z"/></svg>
                </button>
            </div>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <span class="iconify" data-icon="mdi:undo" data-width="20"></span>
            </button>
            <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <span class="iconify" data-icon="mdi:redo" data-width="20"></span>
            </button>
        </div>
        <div class="control-group">
            <button class="btn" id="resetBtn">Reset Grid</button>
        </div>
        <div class="control-group">
            <button class="btn accent" id="saveBtn">Save PNG</button>
            <button class="btn accent" id="saveSvgBtn">Save SVG</button>
        </div>
        <div class="control-group">
            <input type="text" id="infoField" readonly title="Click to copy">
        </div>
        <div class="control-group chroma-group">
            <label>Chroma:</label>
            <button class="icon-btn" id="chromaToggle" title="Enable chroma key">
                <span class="iconify" data-icon="mdi:eye-off" data-width="18"></span>
            </button>
            <div class="color-swatch" id="chromaSwatch" title="Click to pick color">
                <div class="color-swatch-inner" id="chromaSwatchInner"></div>
            </div>
            <input type="color" id="chromaColorPicker" class="color-picker-hidden" value="#00ff00">
            <button class="icon-btn" id="eyedropperBtn" title="Pick color from image (E)">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <input type="range" id="chromaTolerance" min="0" max="150" value="30" class="chroma-slider" title="Color tolerance">
            <span id="chromaToleranceVal" style="min-width: 25px; font-size: 12px; color: #e94560;">30</span>
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <canvas id="mainCanvas"></canvas>
        <div class="drop-zone show-initial" id="dropZone">
            <p>Drop an image here</p>
        </div>
    </div>

    <div class="instructions">
        Drag corners to resize the pixel grid. Drag inside to move it. Use sliders to change grid dimensions.
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const canvas = $('mainCanvas');
        const ctx = canvas.getContext('2d');
        const container = $('canvasContainer');
        const dropZone = $('dropZone');
        const nSlider = $('nSlider'), mSlider = $('mSlider');
        const nInput = $('nInput'), mInput = $('mInput');

        // Global constants
        const MAX_GRID = 500;
        const MAX_UNDO = 50;
        const DEFAULT_N = 16, DEFAULT_M = 16;
        const DEFAULT_RECT_SIZE = 200;
        const MIN_RECT_SIZE = 20;
        const RETINA = window.devicePixelRatio || 1;

        let image = null;
        let gridOpacity = 0.5;
        let sampleMode = 'center';
        let rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
        let dragging = null;
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, width: 0, height: 0 };
        let nStart = DEFAULT_N, mStart = DEFAULT_M;

        let undoStack = [], redoStack = [];

        let aspectLocked = true, lockedAspectRatio = 1;
        let resolutionLocked = true, expandModeOn = false;

        // Chroma key state
        let chromaEnabled = false;
        let chromaColor = [0, 255, 0]; // RGB
        let chromaTolerance = 30;
        let eyedropperMode = false;
        let tileMode = 'square'; // 'square', 'hex', 'hexV', 'tri'

        // Helper to set up exclusive button groups
        function setupBtnGroup(containerId, onChange) {
            const container = $(containerId);
            container.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    onChange(btn.dataset.value);
                    render();
                    autoSave();
                });
            });
        }

        setupBtnGroup('opacityBtns', val => { pushUndo(); gridOpacity = parseInt(val) / 100; });
        setupBtnGroup('sampleBtns', val => { pushUndo(); sampleMode = val; });

        // Unified slider/input handling
        function syncNM(source, newVal) {
            newVal = Math.min(Math.max(1, newVal || 1), MAX_GRID);
            nSlider.value = nInput.value = newVal;
            if (resolutionLocked) mSlider.value = mInput.value = newVal;
            else if (source === 'm') { mSlider.value = mInput.value = newVal; nSlider.value = nInput.value = parseInt(nSlider.value); }
            render();
            autoSave();
        }

        nSlider.addEventListener('input', () => syncNM('n', parseInt(nSlider.value)));
        mSlider.addEventListener('input', () => {
            const val = Math.min(parseInt(mSlider.value), MAX_GRID);
            mSlider.value = mInput.value = val;
            if (resolutionLocked) { nSlider.value = nInput.value = val; }
            render(); autoSave();
        });
        nInput.addEventListener('input', () => syncNM('n', parseInt(nInput.value)));
        mInput.addEventListener('input', () => {
            const val = Math.min(Math.max(1, parseInt(mInput.value) || 1), MAX_GRID);
            mSlider.value = mInput.value = val;
            if (resolutionLocked) { nSlider.value = nInput.value = val; }
            render(); autoSave();
        });

        // Lock icon SVG paths
        const LOCK_CLOSED = '<path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';
        const LOCK_OPEN = '<path d="M12 8h-2V6a2 2 0 10-4 0v2H4V6a4 4 0 118 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';

        function updateLockIcon(btn, locked) {
            btn.querySelector('svg').innerHTML = locked ? LOCK_CLOSED : LOCK_OPEN;
        }

        function setupToggle(btnId, getter, setter, onToggle) {
            const btn = $(btnId);
            btn.addEventListener('click', () => {
                const newVal = !getter();
                setter(newVal);
                btn.classList.toggle('active', newVal);
                if (onToggle) onToggle(newVal, btn);
                autoSave();
            });
        }

        setupToggle('aspectLock', () => aspectLocked, v => { pushUndo(); aspectLocked = v; if (v) lockedAspectRatio = rect.width / rect.height; }, updateLockIcon);
        setupToggle('resolutionLock', () => resolutionLocked, v => { pushUndo(); resolutionLocked = v; }, updateLockIcon);
        setupToggle('expandMode', () => expandModeOn, v => { pushUndo(); expandModeOn = v; });

        setupBtnGroup('tileBtns', val => { pushUndo(); tileMode = val; render(); });

        // Chroma key controls
        function updateChromaSwatch() {
            const [r, g, b] = chromaColor;
            $('chromaSwatchInner').style.background = chromaEnabled ? `rgb(${r},${g},${b})` : 'transparent';
            $('chromaSwatch').style.borderColor = chromaEnabled ? '#e94560' : '#888';
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 255, 0];
        }

        function rgbToHex([r, g, b]) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        $('chromaToggle').addEventListener('click', () => {
            pushUndo();
            chromaEnabled = !chromaEnabled;
            $('chromaToggle').classList.toggle('active', chromaEnabled);
            $('chromaToggle').querySelector('.iconify').dataset.icon = chromaEnabled ? 'mdi:eye' : 'mdi:eye-off';
            updateChromaSwatch();
            render();
            autoSave();
        });

        $('chromaSwatch').addEventListener('click', () => {
            $('chromaColorPicker').value = rgbToHex(chromaColor);
            $('chromaColorPicker').click();
        });

        let chromaPickerUndoPushed = false;
        $('chromaColorPicker').addEventListener('input', e => {
            if (!chromaPickerUndoPushed) { pushUndo(); chromaPickerUndoPushed = true; }
            chromaColor = hexToRgb(e.target.value);
            if (!chromaEnabled) {
                chromaEnabled = true;
                $('chromaToggle').classList.add('active');
                $('chromaToggle').querySelector('.iconify').dataset.icon = 'mdi:eye';
            }
            updateChromaSwatch();
            render();
            autoSave();
        });
        $('chromaColorPicker').addEventListener('change', () => { chromaPickerUndoPushed = false; });

        $('eyedropperBtn').addEventListener('click', () => {
            eyedropperMode = !eyedropperMode;
            $('eyedropperBtn').classList.toggle('active', eyedropperMode);
            canvas.style.cursor = eyedropperMode ? 'crosshair' : 'default';
        });

        let chromaToleranceUndoPushed = false;
        $('chromaTolerance').addEventListener('mousedown', () => { pushUndo(); chromaToleranceUndoPushed = true; });
        $('chromaTolerance').addEventListener('input', e => {
            chromaTolerance = parseInt(e.target.value);
            $('chromaToleranceVal').textContent = chromaTolerance;
            render();
            autoSave();
        });
        $('chromaTolerance').addEventListener('mouseup', () => { chromaToleranceUndoPushed = false; });

        updateChromaSwatch();

        // State helpers - used by undo/redo and localStorage
        function getState() {
            return { rect: { ...rect }, n: parseInt(nSlider.value), m: parseInt(mSlider.value),
                gridOpacity, sampleMode, aspectLocked, lockedAspectRatio, resolutionLocked, expandModeOn,
                nMax: parseInt(nSlider.max), mMax: parseInt(mSlider.max),
                chromaEnabled, chromaColor, chromaTolerance, tileMode };
        }

        function applyState(s) {
            rect = { ...s.rect };
            nSlider.max = mSlider.max = Math.min(s.nMax || 500, 500);
            nSlider.value = nInput.value = Math.min(s.n || 16, 500);
            mSlider.value = mInput.value = Math.min(s.m || 16, 500);
            gridOpacity = s.gridOpacity ?? 0.5;
            sampleMode = s.sampleMode ?? 'center';
            aspectLocked = s.aspectLocked ?? true;
            lockedAspectRatio = s.lockedAspectRatio ?? 1;
            resolutionLocked = s.resolutionLocked ?? true;
            expandModeOn = s.expandModeOn ?? false;
            chromaEnabled = s.chromaEnabled ?? false;
            chromaColor = s.chromaColor ?? [0, 255, 0];
            chromaTolerance = s.chromaTolerance ?? 30;
            tileMode = s.tileMode ?? s.hexMode ? 'hex' : 'square'; // backwards compat

            // Update UI
            $('opacityBtns').querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value == Math.round(gridOpacity * 100)));
            $('sampleBtns').querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value === sampleMode));
            $('tileBtns').querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value === tileMode));
            ['aspectLock', 'resolutionLock'].forEach(id => { const btn = $(id); btn.classList.toggle('active', id === 'aspectLock' ? aspectLocked : resolutionLocked); updateLockIcon(btn, id === 'aspectLock' ? aspectLocked : resolutionLocked); });
            $('expandMode').classList.toggle('active', expandModeOn);
            $('chromaToggle').classList.toggle('active', chromaEnabled);
            $('chromaToggle').querySelector('.iconify').dataset.icon = chromaEnabled ? 'mdi:eye' : 'mdi:eye-off';
            $('chromaTolerance').value = chromaTolerance;
            $('chromaToleranceVal').textContent = chromaTolerance;
            updateChromaSwatch();
        }

        // Undo/redo
        function pushUndo() { undoStack.push(JSON.stringify(getState())); if (undoStack.length > MAX_UNDO) undoStack.shift(); redoStack = []; }
        function undo() { if (!undoStack.length) return; redoStack.push(JSON.stringify(getState())); applyState(JSON.parse(undoStack.pop())); render(); }
        function redo() { if (!redoStack.length) return; undoStack.push(JSON.stringify(getState())); applyState(JSON.parse(redoStack.pop())); render(); }

        $('undoBtn').addEventListener('click', undo);
        $('redoBtn').addEventListener('click', redo);

        // LocalStorage
        function autoSave() {
            localStorage.setItem('pixelArtToolState', JSON.stringify(getState()));
            if (image) {
                const tc = document.createElement('canvas');
                tc.width = image.width; tc.height = image.height;
                tc.getContext('2d').drawImage(image, 0, 0);
                localStorage.setItem('pixelArtToolImage', tc.toDataURL('image/png'));
            }
        }

        function loadFromLocalStorage() {
            const stateJson = localStorage.getItem('pixelArtToolState');
            const imageData = localStorage.getItem('pixelArtToolImage');
            if (imageData) {
                const img = new Image();
                img.onload = () => { image = img; resizeCanvas(); dropZone.classList.remove('show-initial'); if (stateJson) applyState(JSON.parse(stateJson)); render(); };
                img.src = imageData;
            } else if (stateJson) applyState(JSON.parse(stateJson));
        }

        // Color sampling
        function sampleCell(imgData, x0, y0, x1, y1, width) {
            x0 = Math.max(0, Math.floor(x0)); y0 = Math.max(0, Math.floor(y0));
            x1 = Math.min(width, Math.floor(x1)); y1 = Math.min(imgData.height, Math.floor(y1));
            if (x1 <= x0 || y1 <= y0) return null;

            if (sampleMode === 'center') {
                const idx = (Math.floor((y0 + y1) / 2) * width + Math.floor((x0 + x1) / 2)) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                const idx = (y * width + x) * 4;
                pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
            }
            if (!pixels.length) return null;

            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            // median
            const mid = Math.floor(pixels.length / 2);
            return [0, 1, 2].map(i => pixels.map(p => p[i]).sort((a, b) => a - b)[mid]);
        }

        // Info field
        function updateInfoField() {
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            $('infoField').value = `x=${rect.x.toFixed(1)} y=${rect.y.toFixed(1)} w=${rect.width.toFixed(1)} h=${rect.height.toFixed(1)} n=${n} m=${m}`;
        }
        $('infoField').addEventListener('click', function() { this.select(); navigator.clipboard.writeText(this.value); });

        // Save PNG
        $('saveBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const outCanvas = document.createElement('canvas');
            outCanvas.width = n; outCanvas.height = m;
            const outCtx = outCanvas.getContext('2d');

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
            tempCanvas.getContext('2d').drawImage(image, 0, 0, canvas.width, canvas.height);
            const imgData = tempCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);

            const cellW = rect.width / n, cellH = rect.height / m;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                const color = sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, canvas.width);
                if (color) {
                    // Apply chroma key to saved image (hard threshold)
                    const alpha = chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance ? 0 : 1;
                    outCtx.fillStyle = `rgba(${color.map(Math.round).join(',')},${alpha})`;
                    outCtx.fillRect(col, row, 1, 1);
                }
            }

            const link = document.createElement('a');
            link.download = `pixel_art_x${rect.x.toFixed(0)}_y${rect.y.toFixed(0)}_w${rect.width.toFixed(0)}_h${rect.height.toFixed(0)}_n${n}_m${m}.png`;
            link.href = outCanvas.toDataURL('image/png');
            link.click();
        });

        // Save SVG - preserves exact tile geometry
        $('saveSvgBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
            tempCanvas.getContext('2d').drawImage(image, 0, 0, canvas.width, canvas.height);
            const imgData = tempCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);

            // SVG dimensions - use a reasonable output size
            const svgW = 800, svgH = 800 * (rect.height / rect.width);
            const scaleX = svgW / rect.width, scaleY = svgH / rect.height;

            let paths = '';

            function rgbToFill(color) {
                if (!color) return null;
                if (chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance) {
                    return null; // transparent
                }
                return `rgb(${color.map(Math.round).join(',')})`;
            }

            if (tileMode === 'hex') {
                const { hexW, hexH, halfW, halfH } = getHexGeometry(n, m, rect.width, rect.height);
                for (let col = 0; col < n; col++) {
                    for (let row = 0; row < m; row++) {
                        const { x: cx, y: cy } = getHexCenter(col, row, hexW, hexH, 0, 0);
                        const color = sampleHexCell(imgData, rect.x + cx, rect.y + cy, halfW, halfH, canvas.width, canvas.height);
                        const fill = rgbToFill(color);
                        if (fill) {
                            // Flat-top hex vertices
                            const pts = [
                                [cx + halfW, cy],
                                [cx + halfW * 0.5, cy - halfH],
                                [cx - halfW * 0.5, cy - halfH],
                                [cx - halfW, cy],
                                [cx - halfW * 0.5, cy + halfH],
                                [cx + halfW * 0.5, cy + halfH]
                            ].map(([x, y]) => `${(x * scaleX).toFixed(2)},${(y * scaleY).toFixed(2)}`).join(' ');
                            paths += `<polygon points="${pts}" fill="${fill}"/>\n`;
                        }
                    }
                }
            } else if (tileMode === 'hexV') {
                const { hexW, hexH, halfW, halfH } = getHexVGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const { x: cx, y: cy } = getHexVCenter(col, row, hexW, hexH, 0, 0);
                        const color = sampleHexVCell(imgData, rect.x + cx, rect.y + cy, halfW, halfH, canvas.width, canvas.height);
                        const fill = rgbToFill(color);
                        if (fill) {
                            // Pointy-top hex vertices
                            const pts = [
                                [cx, cy - halfH],
                                [cx + halfW, cy - halfH * 0.5],
                                [cx + halfW, cy + halfH * 0.5],
                                [cx, cy + halfH],
                                [cx - halfW, cy + halfH * 0.5],
                                [cx - halfW, cy - halfH * 0.5]
                            ].map(([x, y]) => `${(x * scaleX).toFixed(2)},${(y * scaleY).toFixed(2)}`).join(' ');
                            paths += `<polygon points="${pts}" fill="${fill}"/>\n`;
                        }
                    }
                }
            } else if (tileMode === 'tri') {
                const { triW, triH } = getTriGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const tri = getTriVertices(col, row, triW, triH, 0, 0);
                        const color = sampleTriCell(imgData, { ...tri, cx: rect.x + tri.cx, cy: rect.y + tri.cy, x0: rect.x + tri.x0, y0: rect.y + tri.y0, x1: rect.x + tri.x1, y1: rect.y + tri.y1, x2: rect.x + tri.x2, y2: rect.y + tri.y2 }, canvas.width, canvas.height);
                        const fill = rgbToFill(color);
                        if (fill) {
                            const pts = [
                                [tri.x0, tri.y0],
                                [tri.x1, tri.y1],
                                [tri.x2, tri.y2]
                            ].map(([x, y]) => `${(x * scaleX).toFixed(2)},${(y * scaleY).toFixed(2)}`).join(' ');
                            paths += `<polygon points="${pts}" fill="${fill}"/>\n`;
                        }
                    }
                }
            } else {
                // Square
                const cellW = rect.width / n, cellH = rect.height / m;
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const color = sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, canvas.width);
                        const fill = rgbToFill(color);
                        if (fill) {
                            paths += `<rect x="${(col * cellW * scaleX).toFixed(2)}" y="${(row * cellH * scaleY).toFixed(2)}" width="${(cellW * scaleX).toFixed(2)}" height="${(cellH * scaleY).toFixed(2)}" fill="${fill}"/>\n`;
                        }
                    }
                }
            }

            const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${svgW.toFixed(0)}" height="${svgH.toFixed(0)}" viewBox="0 0 ${svgW.toFixed(0)} ${svgH.toFixed(0)}">
${paths}</svg>`;

            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `pixel_art_${tileMode}_n${n}_m${m}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        });

        // Reset
        $('resetBtn').addEventListener('click', () => {
            nSlider.value = nInput.value = DEFAULT_N;
            mSlider.value = mInput.value = DEFAULT_M;
            if (image) { rect.width = rect.height = DEFAULT_RECT_SIZE; rect.x = (canvas.width - DEFAULT_RECT_SIZE) / 2; rect.y = (canvas.height - DEFAULT_RECT_SIZE) / 2; }
            else rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
            aspectLocked = false; $('aspectLock').classList.remove('active'); updateLockIcon($('aspectLock'), false);
            lockedAspectRatio = 1;
            render(); autoSave();
        });

        // Drag and drop
        container.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('active'); });
        container.addEventListener('dragleave', e => { if (!container.contains(e.relatedTarget)) dropZone.classList.remove('active'); });
        container.addEventListener('drop', e => {
            e.preventDefault(); dropZone.classList.remove('active', 'show-initial');
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('image/')) loadImage(file);
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    image = img; resizeCanvas();
                    render(); autoSave();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        let canvasScale = 1; // scale from image coords to display coords

        function resizeCanvas() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            canvasScale = Math.min((cr.width - 40) / image.width, (cr.height - 40) / image.height, 1);
            const displayW = image.width * canvasScale;
            const displayH = image.height * canvasScale;
            // Set canvas size for retina: internal pixels = display pixels * devicePixelRatio
            canvas.width = displayW * RETINA;
            canvas.height = displayH * RETINA;
            canvas.style.width = displayW + 'px';
            canvas.style.height = displayH + 'px';
            // Scale context so we can draw in image coordinates
            ctx.setTransform(canvasScale * RETINA, 0, 0, canvasScale * RETINA, 0, 0);
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2);
        }

        // Hexagon helper functions - stretched to fit grid
        function drawHexPath(ctx, cx, cy, halfW, halfH) {
            // Flat-top hexagon, stretched to fit halfW (horizontal) and halfH (vertical)
            ctx.beginPath();
            // 6 vertices of flat-top hex: right, top-right, top-left, left, bottom-left, bottom-right
            ctx.moveTo(cx + halfW, cy);
            ctx.lineTo(cx + halfW * 0.5, cy - halfH);
            ctx.lineTo(cx - halfW * 0.5, cy - halfH);
            ctx.lineTo(cx - halfW, cy);
            ctx.lineTo(cx - halfW * 0.5, cy + halfH);
            ctx.lineTo(cx + halfW * 0.5, cy + halfH);
            ctx.closePath();
        }

        function getHexGeometry(n, m, rectW, rectH) {
            // Calculate hex dimensions to perfectly tile the rect
            // Flat-top hex: horizontal spacing = 1.5 * hexW, vertical spacing = hexH (with 0.5 offset for odd cols)
            const hexW = rectW / (n * 0.75 + 0.25);
            const hexH = rectH / (m + 0.5);
            return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
        }

        function getHexCenter(col, row, hexW, hexH, offsetX, offsetY) {
            // Flat-top hexagon layout (offset odd columns)
            const x = offsetX + col * hexW * 0.75 + hexW / 2;
            const y = offsetY + row * hexH + (col % 2 === 1 ? hexH / 2 : 0) + hexH / 2;
            return { x, y };
        }

        function pointInHex(px, py, cx, cy, halfW, halfH) {
            // Check if point is inside stretched hexagon
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            // Check against slanted edges: the hex edge goes from (halfW, 0) to (halfW/2, halfH)
            return halfH * halfW - halfH * dx - halfW * 0.5 * dy >= 0;
        }

        function sampleHexCell(imgData, cx, cy, halfW, halfH, width, height) {
            const x0 = Math.max(0, Math.floor(cx - halfW));
            const y0 = Math.max(0, Math.floor(cy - halfH));
            const x1 = Math.min(width, Math.ceil(cx + halfW));
            const y1 = Math.min(height, Math.ceil(cy + halfH));

            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                if (idx >= 0 && idx < imgData.data.length - 3) {
                    return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                }
                return null;
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) {
                for (let x = x0; x < x1; x++) {
                    if (pointInHex(x + 0.5, y + 0.5, cx, cy, halfW, halfH)) {
                        const idx = (y * width + x) * 4;
                        pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    }
                }
            }
            if (!pixels.length) return null;

            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            // median
            const mid = Math.floor(pixels.length / 2);
            return [0, 1, 2].map(i => pixels.map(p => p[i]).sort((a, b) => a - b)[mid]);
        }

        // Pointy-top hexagon helpers (rotated 90 degrees from flat-top)
        function drawHexVPath(ctx, cx, cy, halfW, halfH) {
            // Pointy-top hexagon, stretched to fit halfW (horizontal) and halfH (vertical)
            ctx.beginPath();
            // 6 vertices: top, top-right, bottom-right, bottom, bottom-left, top-left
            ctx.moveTo(cx, cy - halfH);
            ctx.lineTo(cx + halfW, cy - halfH * 0.5);
            ctx.lineTo(cx + halfW, cy + halfH * 0.5);
            ctx.lineTo(cx, cy + halfH);
            ctx.lineTo(cx - halfW, cy + halfH * 0.5);
            ctx.lineTo(cx - halfW, cy - halfH * 0.5);
            ctx.closePath();
        }

        function getHexVGeometry(n, m, rectW, rectH) {
            // Pointy-top hex: vertical spacing = 1.5 * hexH, horizontal spacing = hexW (with 0.5 offset for odd rows)
            const hexW = rectW / (n + 0.5);
            const hexH = rectH / (m * 0.75 + 0.25);
            return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
        }

        function getHexVCenter(col, row, hexW, hexH, offsetX, offsetY) {
            // Pointy-top hexagon layout (offset odd rows)
            const x = offsetX + col * hexW + (row % 2 === 1 ? hexW / 2 : 0) + hexW / 2;
            const y = offsetY + row * hexH * 0.75 + hexH / 2;
            return { x, y };
        }

        function pointInHexV(px, py, cx, cy, halfW, halfH) {
            // Check if point is inside stretched pointy-top hexagon
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            // Check against slanted edges: the hex edge goes from (0, halfH) to (halfW, halfH/2)
            return halfW * halfH - halfW * dy - halfH * 0.5 * dx >= 0;
        }

        function sampleHexVCell(imgData, cx, cy, halfW, halfH, width, height) {
            const x0 = Math.max(0, Math.floor(cx - halfW));
            const y0 = Math.max(0, Math.floor(cy - halfH));
            const x1 = Math.min(width, Math.ceil(cx + halfW));
            const y1 = Math.min(height, Math.ceil(cy + halfH));

            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                if (idx >= 0 && idx < imgData.data.length - 3) {
                    return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                }
                return null;
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) {
                for (let x = x0; x < x1; x++) {
                    if (pointInHexV(x + 0.5, y + 0.5, cx, cy, halfW, halfH)) {
                        const idx = (y * width + x) * 4;
                        pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    }
                }
            }
            if (!pixels.length) return null;

            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            // median
            const mid = Math.floor(pixels.length / 2);
            return [0, 1, 2].map(i => pixels.map(p => p[i]).sort((a, b) => a - b)[mid]);
        }

        // Triangle helper functions - stretched to fit grid
        function drawTriPath(ctx, x0, y0, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.closePath();
        }

        function getTriGeometry(n, m, rectW, rectH) {
            // n = columns of triangles (alternating up/down), m = rows
            // Each pair of triangles (up+down) spans one "cell width"
            const triW = rectW / ((n + 1) / 2);
            const triH = rectH / m;
            return { triW, triH };
        }

        function getTriVertices(col, row, triW, triH, offsetX, offsetY) {
            // Alternating up/down triangles that perfectly tessellate
            const isUp = (col + row) % 2 === 0;
            const baseX = offsetX + col * triW / 2;
            const baseY = offsetY + row * triH;

            if (isUp) {
                // Point at top
                return {
                    x0: baseX + triW / 2, y0: baseY,
                    x1: baseX, y1: baseY + triH,
                    x2: baseX + triW, y2: baseY + triH,
                    cx: baseX + triW / 2, cy: baseY + triH * 2 / 3
                };
            } else {
                // Point at bottom
                return {
                    x0: baseX, y0: baseY,
                    x1: baseX + triW, y1: baseY,
                    x2: baseX + triW / 2, y2: baseY + triH,
                    cx: baseX + triW / 2, cy: baseY + triH / 3
                };
            }
        }

        function pointInTriangle(px, py, x0, y0, x1, y1, x2, y2) {
            const area = 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2);
            const s = 1 / (2 * area) * (y0 * x2 - x0 * y2 + (y2 - y0) * px + (x0 - x2) * py);
            const t = 1 / (2 * area) * (x0 * y1 - y0 * x1 + (y0 - y1) * px + (x1 - x0) * py);
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }

        function sampleTriCell(imgData, tri, width, height) {
            const { x0, y0, x1, y1, x2, y2, cx, cy } = tri;
            const minX = Math.max(0, Math.floor(Math.min(x0, x1, x2)));
            const maxX = Math.min(width, Math.ceil(Math.max(x0, x1, x2)));
            const minY = Math.max(0, Math.floor(Math.min(y0, y1, y2)));
            const maxY = Math.min(height, Math.ceil(Math.max(y0, y1, y2)));

            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                if (idx >= 0 && idx < imgData.data.length - 3) {
                    return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                }
                return null;
            }

            const pixels = [];
            for (let y = minY; y < maxY; y++) {
                for (let x = minX; x < maxX; x++) {
                    if (pointInTriangle(x + 0.5, y + 0.5, x0, y0, x1, y1, x2, y2)) {
                        const idx = (y * width + x) * 4;
                        pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    }
                }
            }
            if (!pixels.length) return null;

            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            // median
            const mid = Math.floor(pixels.length / 2);
            return [0, 1, 2].map(i => pixels.map(p => p[i]).sort((a, b) => a - b)[mid]);
        }

        function render() {
            if (!image) return;
            // Draw in image coordinates (transform handles scaling to canvas)
            ctx.clearRect(0, 0, image.width, image.height);
            ctx.drawImage(image, 0, 0, image.width, image.height);

            // Get image data at original resolution for sampling
            const sampleCanvas = document.createElement('canvas');
            sampleCanvas.width = image.width;
            sampleCanvas.height = image.height;
            const sampleCtx = sampleCanvas.getContext('2d');
            sampleCtx.drawImage(image, 0, 0);
            const imgData = sampleCtx.getImageData(0, 0, image.width, image.height);

            // Apply chroma key (hard threshold) to display
            if (chromaEnabled) {
                const displayData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = displayData.data;
                const [cr, cg, cb] = chromaColor;
                for (let i = 0; i < data.length; i += 4) {
                    if (colorDistance(data[i], data[i + 1], data[i + 2], cr, cg, cb) <= chromaTolerance) {
                        data[i + 3] = 0;
                    }
                }
                ctx.putImageData(displayData, 0, 0);
            }

            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const cellW = rect.width / n, cellH = rect.height / m;
            const lineWidth = 1 / canvasScale; // 1 screen pixel in image coords

            if (tileMode === 'hex') {
                // Flat-top hexagonal grid rendering
                const { hexW, hexH, halfW, halfH } = getHexGeometry(n, m, rect.width, rect.height);

                if (gridOpacity > 0) {
                    ctx.save(); ctx.globalAlpha = gridOpacity;
                    for (let col = 0; col < n; col++) {
                        for (let row = 0; row < m; row++) {
                            const { x: cx, y: cy } = getHexCenter(col, row, hexW, hexH, rect.x, rect.y);
                            const color = sampleHexCell(imgData, cx, cy, halfW, halfH, image.width, image.height);
                            if (color) {
                                ctx.fillStyle = `rgb(${color.map(Math.round).join(',')})`;
                                drawHexPath(ctx, cx, cy, halfW, halfH);
                                ctx.fill();
                            }
                        }
                    }
                    ctx.restore();
                }

                // Hex grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = lineWidth;
                for (let col = 0; col < n; col++) {
                    for (let row = 0; row < m; row++) {
                        const { x: cx, y: cy } = getHexCenter(col, row, hexW, hexH, rect.x, rect.y);
                        drawHexPath(ctx, cx, cy, halfW, halfH);
                        ctx.stroke();
                    }
                }
            } else if (tileMode === 'hexV') {
                // Pointy-top hexagonal grid rendering
                const { hexW, hexH, halfW, halfH } = getHexVGeometry(n, m, rect.width, rect.height);

                if (gridOpacity > 0) {
                    ctx.save(); ctx.globalAlpha = gridOpacity;
                    for (let row = 0; row < m; row++) {
                        for (let col = 0; col < n; col++) {
                            const { x: cx, y: cy } = getHexVCenter(col, row, hexW, hexH, rect.x, rect.y);
                            const color = sampleHexVCell(imgData, cx, cy, halfW, halfH, image.width, image.height);
                            if (color) {
                                ctx.fillStyle = `rgb(${color.map(Math.round).join(',')})`;
                                drawHexVPath(ctx, cx, cy, halfW, halfH);
                                ctx.fill();
                            }
                        }
                    }
                    ctx.restore();
                }

                // Hex grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = lineWidth;
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const { x: cx, y: cy } = getHexVCenter(col, row, hexW, hexH, rect.x, rect.y);
                        drawHexVPath(ctx, cx, cy, halfW, halfH);
                        ctx.stroke();
                    }
                }
            } else if (tileMode === 'tri') {
                // Triangle grid rendering - stretched to perfectly tile the rect
                const { triW, triH } = getTriGeometry(n, m, rect.width, rect.height);

                if (gridOpacity > 0) {
                    ctx.save(); ctx.globalAlpha = gridOpacity;
                    for (let row = 0; row < m; row++) {
                        for (let col = 0; col < n; col++) {
                            const tri = getTriVertices(col, row, triW, triH, rect.x, rect.y);
                            const color = sampleTriCell(imgData, tri, image.width, image.height);
                            if (color) {
                                ctx.fillStyle = `rgb(${color.map(Math.round).join(',')})`;
                                drawTriPath(ctx, tri.x0, tri.y0, tri.x1, tri.y1, tri.x2, tri.y2);
                                ctx.fill();
                            }
                        }
                    }
                    ctx.restore();
                }

                // Triangle grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = lineWidth;
                for (let row = 0; row < m; row++) {
                    for (let col = 0; col < n; col++) {
                        const tri = getTriVertices(col, row, triW, triH, rect.x, rect.y);
                        drawTriPath(ctx, tri.x0, tri.y0, tri.x1, tri.y1, tri.x2, tri.y2);
                        ctx.stroke();
                    }
                }
            } else {
                // Square grid rendering
                if (gridOpacity > 0) {
                    ctx.save(); ctx.globalAlpha = gridOpacity;
                    for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                        const cellX = rect.x + col * cellW, cellY = rect.y + row * cellH;
                        if (cellX + cellW < 0 || cellX > image.width || cellY + cellH < 0 || cellY > image.height) continue;
                        const color = sampleCell(imgData, cellX, cellY, cellX + cellW, cellY + cellH, image.width);
                        if (color) { ctx.fillStyle = `rgb(${color.map(Math.round).join(',')})`; ctx.fillRect(cellX, cellY, cellW + 0.5, cellH + 0.5); }
                    }
                    ctx.restore();
                }

                // Grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = lineWidth;
                ctx.beginPath();
                for (let i = 0; i <= n; i++) { const x = rect.x + i * cellW; ctx.moveTo(x, rect.y); ctx.lineTo(x, rect.y + rect.height); }
                for (let i = 0; i <= m; i++) { const y = rect.y + i * cellH; ctx.moveTo(rect.x, y); ctx.lineTo(rect.x + rect.width, y); }
                ctx.stroke();
            }

            // Border and handles
            ctx.strokeStyle = '#e94560'; ctx.lineWidth = 2 * lineWidth;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            ctx.fillStyle = '#e94560';
            const hs = 10 / canvasScale; // 10 screen pixels in image coords
            [[0, 0], [1, 0], [0, 1], [1, 1]].forEach(([cx, cy]) => {
                ctx.fillRect(rect.x + cx * rect.width - hs / 2, rect.y + cy * rect.height - hs / 2, hs, hs);
            });

            updateInfoField();
        }

        function getMousePos(e) {
            const cr = canvas.getBoundingClientRect();
            // Convert screen coords to image coords
            return { x: (e.clientX - cr.left) / canvasScale, y: (e.clientY - cr.top) / canvasScale };
        }

        function getHitZone(pos) {
            const hs = 15 / canvasScale; // 15 screen pixels converted to image coords
            const corners = [['tl', 0, 0], ['tr', 1, 0], ['bl', 0, 1], ['br', 1, 1]];
            for (const [id, cx, cy] of corners) {
                if (Math.abs(pos.x - (rect.x + cx * rect.width)) < hs && Math.abs(pos.y - (rect.y + cy * rect.height)) < hs) return id;
            }
            const inX = pos.x > rect.x && pos.x < rect.x + rect.width;
            const inY = pos.y > rect.y && pos.y < rect.y + rect.height;
            if (Math.abs(pos.x - rect.x) < hs && inY) return 'left';
            if (Math.abs(pos.x - rect.x - rect.width) < hs && inY) return 'right';
            if (Math.abs(pos.y - rect.y) < hs && inX) return 'top';
            if (Math.abs(pos.y - rect.y - rect.height) < hs && inX) return 'bottom';
            if (inX && inY) return 'move';
            return null;
        }

        const CURSORS = { tl: 'nwse-resize', br: 'nwse-resize', tr: 'nesw-resize', bl: 'nesw-resize', left: 'ew-resize', right: 'ew-resize', top: 'ns-resize', bottom: 'ns-resize', move: 'move' };

        canvas.addEventListener('mousedown', e => {
            const pos = getMousePos(e);

            // Eyedropper mode - pick color from image
            if (eyedropperMode && image) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(image, 0, 0, canvas.width, canvas.height);
                const pixel = tempCtx.getImageData(Math.floor(pos.x), Math.floor(pos.y), 1, 1).data;
                chromaColor = [pixel[0], pixel[1], pixel[2]];
                $('chromaColorPicker').value = rgbToHex(chromaColor);
                if (!chromaEnabled) {
                    chromaEnabled = true;
                    $('chromaToggle').classList.add('active');
                    $('chromaToggle').querySelector('.iconify').dataset.icon = 'mdi:eye';
                }
                updateChromaSwatch();
                eyedropperMode = false;
                $('eyedropperBtn').classList.remove('active');
                canvas.style.cursor = 'default';
                render();
                autoSave();
                return;
            }

            dragging = getHitZone(pos);
            if (dragging) { pushUndo(); dragStart = pos; rectStart = { ...rect }; nStart = parseInt(nSlider.value); mStart = parseInt(mSlider.value); }
        });

        canvas.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            canvas.style.cursor = eyedropperMode ? 'crosshair' : (CURSORS[getHitZone(pos)] || 'default');
        });

        window.addEventListener('mousemove', e => {
            if (!dragging) return;

            const pos = getMousePos(e);
            let dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            if (e.shiftKey) { dx /= 10; dy /= 10; }
            if (e.ctrlKey || e.metaKey) { if (Math.abs(dx) > Math.abs(dy)) dy = 0; else dx = 0; }

            if (dragging === 'move') {
                let newX = rectStart.x + dx, newY = rectStart.y + dy;
                if (expandModeOn && !e.shiftKey) {
                    // Snap relative to original position based on tile geometry
                    const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);
                    const snappedDx = Math.round(dx / snap.dx) * snap.dx;
                    const snappedDy = Math.round(dy / snap.dy) * snap.dy;
                    newX = rectStart.x + snappedDx;
                    newY = rectStart.y + snappedDy;
                }
                rect.x = newX; rect.y = newY;
            } else if (expandModeOn) {
                handleExpandResize(dx, dy);
            } else {
                // Edges always use free resize (axis-locked), corners use aspect resize if locked
                const isEdge = ['left', 'right', 'top', 'bottom'].includes(dragging);
                if (aspectLocked && !isEdge) {
                    handleAspectResize(dx, dy);
                } else {
                    handleFreeResize(dx, dy);
                }
            }
            render();
        });

        // Get snap units for each tile mode - how much to move per tile add/remove
        function getTileSnapUnits(n, m, w, h) {
            if (tileMode === 'hex') {
                // Flat-top hex: cols spaced at 0.75 * hexW, rows at hexH
                const hexW = w / (n * 0.75 + 0.25);
                const hexH = h / (m + 0.5);
                return { dx: hexW * 0.75, dy: hexH };
            } else if (tileMode === 'hexV') {
                // Pointy-top hex: cols spaced at hexW, rows at 0.75 * hexH
                const hexW = w / (n + 0.5);
                const hexH = h / (m * 0.75 + 0.25);
                return { dx: hexW, dy: hexH * 0.75 };
            } else if (tileMode === 'tri') {
                // Triangle: each col is half a triangle width
                const triW = w / ((n + 1) / 2);
                const triH = h / m;
                return { dx: triW / 2, dy: triH };
            } else {
                // Square
                return { dx: w / n, dy: h / m };
            }
        }

        // Calculate new rect dimensions when adding/removing tiles
        function calcExpandedRect(newN, newM, anchorX, anchorY) {
            // anchorX/anchorY: 0 = anchor at start (left/top), 1 = anchor at end (right/bottom)
            let newW, newH, newX = rectStart.x, newY = rectStart.y;

            if (tileMode === 'hex') {
                // Flat-top hex: width = hexW * (n * 0.75 + 0.25)
                const hexW = rectStart.width / (nStart * 0.75 + 0.25);
                const hexH = rectStart.height / (mStart + 0.5);
                newW = hexW * (newN * 0.75 + 0.25);
                newH = hexH * (newM + 0.5);
                if (anchorX) newX = rectStart.x + rectStart.width - newW;
                if (anchorY) newY = rectStart.y + rectStart.height - newH;
            } else if (tileMode === 'hexV') {
                // Pointy-top hex: height = hexH * (m * 0.75 + 0.25)
                const hexW = rectStart.width / (nStart + 0.5);
                const hexH = rectStart.height / (mStart * 0.75 + 0.25);
                newW = hexW * (newN + 0.5);
                newH = hexH * (newM * 0.75 + 0.25);
                if (anchorX) newX = rectStart.x + rectStart.width - newW;
                if (anchorY) newY = rectStart.y + rectStart.height - newH;
            } else if (tileMode === 'tri') {
                // Triangle: width = triW * ((n + 1) / 2)
                const triW = rectStart.width / ((nStart + 1) / 2);
                const triH = rectStart.height / mStart;
                newW = triW * ((newN + 1) / 2);
                newH = triH * newM;
                if (anchorX) newX = rectStart.x + rectStart.width - newW;
                if (anchorY) newY = rectStart.y + rectStart.height - newH;
            } else {
                // Square
                const cellW = rectStart.width / nStart;
                const cellH = rectStart.height / mStart;
                newW = newN * cellW;
                newH = newM * cellH;
                if (anchorX) newX = rectStart.x + rectStart.width - newW;
                if (anchorY) newY = rectStart.y + rectStart.height - newH;
            }

            return { x: newX, y: newY, width: newW, height: newH };
        }

        function handleExpandResize(dx, dy) {
            const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);

            // Direction multipliers: [dxSign, dySign, anchorX, anchorY]
            const cfg = {
                br: [1, 1, 0, 0], tl: [-1, -1, 1, 1], tr: [1, -1, 0, 1], bl: [-1, 1, 1, 0],
                right: [1, 0, 0, 0], left: [-1, 0, 1, 0], bottom: [0, 1, 0, 0], top: [0, -1, 0, 1]
            }[dragging];
            if (!cfg) return;

            const [dxs, dys, ax, ay] = cfg;

            // Only compute cell deltas for axes that this handle affects
            const cellDx = dxs ? Math.round(dx / snap.dx) : 0;
            const cellDy = dys ? Math.round(dy / snap.dy) : 0;

            const newN = Math.min(Math.max(1, nStart + dxs * cellDx), MAX_GRID);
            const newM = Math.min(Math.max(1, mStart + dys * cellDy), MAX_GRID);

            const newRect = calcExpandedRect(newN, newM, ax, ay);
            if (dxs) { rect.width = newRect.width; rect.x = newRect.x; nSlider.value = nInput.value = newN; }
            if (dys) { rect.height = newRect.height; rect.y = newRect.y; mSlider.value = mInput.value = newM; }
        }

        function handleAspectResize(dx, dy) {
            const sf = Math.max(Math.abs(dx) / rectStart.width, Math.abs(dy) / rectStart.height);

            if (['br', 'tl', 'tr', 'bl'].includes(dragging)) {
                const signs = { br: dx + dy, tl: -(dx + dy), tr: dx - dy, bl: -dx + dy };
                const sign = signs[dragging] > 0 ? 1 : -1;
                const newW = Math.max(MIN_RECT_SIZE, rectStart.width * (1 + sign * sf));
                const newH = newW / lockedAspectRatio;
                rect.width = newW; rect.height = newH;
                if (dragging[0] === 't') rect.y = rectStart.y + rectStart.height - newH;
                if (dragging[1] === 'l') rect.x = rectStart.x + rectStart.width - newW;
            } else {
                // Edge resize - scale from opposite edge center
                const isHoriz = dragging === 'left' || dragging === 'right';
                const delta = isHoriz ? dx : dy;
                const fromStart = dragging === 'left' || dragging === 'top';

                if (isHoriz) {
                    const newW = Math.max(MIN_RECT_SIZE, rectStart.width + (fromStart ? -delta : delta));
                    const newH = newW / lockedAspectRatio;
                    const centerY = rectStart.y + rectStart.height / 2;
                    rect.width = newW; rect.height = newH; rect.y = centerY - newH / 2;
                    if (fromStart) rect.x = rectStart.x + rectStart.width - newW;
                } else {
                    // Vertical edge - anchor top for bottom, anchor bottom for top
                    const newH = Math.max(MIN_RECT_SIZE, rectStart.height + (fromStart ? -delta : delta));
                    const newW = newH * lockedAspectRatio;
                    const centerX = rectStart.x + rectStart.width / 2;
                    rect.width = newW; rect.height = newH; rect.x = centerX - newW / 2;
                    if (fromStart) rect.y = rectStart.y + rectStart.height - newH;
                    // else: rect.y stays at rectStart.y (anchor top edge)
                }
            }
        }

        function handleFreeResize(dx, dy) {
            const isLeft = dragging.includes('l') || dragging === 'left';
            const isTop = dragging.includes('t') || dragging === 'top';
            const isRight = dragging.includes('r') || dragging === 'right';
            const isBottom = dragging.includes('b') || dragging === 'bottom';

            if (isRight || (dragging.length === 2 && dragging[1] === 'r')) rect.width = Math.max(MIN_RECT_SIZE, rectStart.width + dx);
            if (isBottom || (dragging.length === 2 && dragging[0] === 'b')) rect.height = Math.max(MIN_RECT_SIZE, rectStart.height + dy);
            if (isLeft) { const nw = Math.max(MIN_RECT_SIZE, rectStart.width - dx); rect.x = rectStart.x + rectStart.width - nw; rect.width = nw; }
            if (isTop) { const nh = Math.max(MIN_RECT_SIZE, rectStart.height - dy); rect.y = rectStart.y + rectStart.height - nh; rect.height = nh; }
        }

        window.addEventListener('mouseup', () => { if (dragging) autoSave(); dragging = null; });
        window.addEventListener('resize', () => { if (image) { resizeCanvas(); render(); } });

        // Keyboard shortcuts
        window.addEventListener('keydown', e => {
            if ('123'.includes(e.key)) {
                pushUndo();
                const opacity = { '1': 0, '2': 50, '3': 100 }[e.key];
                $('opacityBtns').querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value == opacity));
                gridOpacity = opacity / 100; render(); autoSave();
            } else if (e.key.toLowerCase() === 's') { e.preventDefault(); $('saveBtn').click(); }
            else if (e.key.toLowerCase() === 'g') { e.preventDefault(); $('saveSvgBtn').click(); }
            else if (e.key.toLowerCase() === 'x') { $('expandMode').click(); }
            else if (e.key.toLowerCase() === 'h') {
                // Cycle tile modes: square -> hex -> hexV -> tri -> square
                pushUndo();
                const modes = ['square', 'hex', 'hexV', 'tri'];
                const nextIdx = (modes.indexOf(tileMode) + 1) % modes.length;
                tileMode = modes[nextIdx];
                $('tileBtns').querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value === tileMode));
                render(); autoSave();
            }
            else if (e.key.toLowerCase() === 'e') { $('eyedropperBtn').click(); }
            else if (e.key.toLowerCase() === 'c') { $('chromaToggle').click(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        loadFromLocalStorage();
    </script>
</body>
</html>

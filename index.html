<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Alignment Tool</title>
    <script src="https://code.iconify.design/3/3.1.0/iconify.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .controls {
            padding: 15px 20px;
            background: #16213e;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #0f3460;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label { font-size: 14px; color: #aaa; }
        .control-group input[type="range"] { width: 200px; cursor: pointer; }
        .btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .btn:hover { background: #1a4a7a; }
        .btn.active { background: #e94560; color: white; }
        .btn.accent { background: #e94560; }
        .icon-btn {
            background: #0f3460;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 6px 10px;
            color: #888;
            transition: all 0.2s;
            font-size: 16px;
        }
        .icon-btn:hover { background: #1a4a7a; }
        .icon-btn.active { color: #e94560; }
        .btn-group { display: flex; gap: 5px; }
        .slider-group { display: flex; align-items: center; gap: 8px; }
        .slider-pair { display: flex; flex-direction: column; gap: 6px; }
        .num-input {
            width: 50px;
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 4px;
            border-radius: 4px;
            text-align: center;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #canvasWrapper {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }
        #mainSvg { display: block; overflow: visible; }
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(26, 26, 46, 0.9);
            border: 3px dashed #e94560;
            margin: 20px;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .drop-zone.active, .drop-zone.show-initial { opacity: 1; }
        .drop-zone.show-initial { pointer-events: auto; }
        .drop-zone p { font-size: 24px; color: #e94560; }
        .instructions {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            max-width: 300px;
        }
        #infoField {
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 320px;
            cursor: pointer;
        }
        .chroma-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 4px;
        }
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid #888;
            cursor: pointer;
            background: conic-gradient(#808080 25%, #fff 25% 50%, #808080 50% 75%, #fff 75%);
            background-size: 8px 8px;
        }
        .color-swatch-inner {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }
        .color-picker-hidden {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }
        .chroma-slider {
            width: 80px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group slider-group">
            <div class="slider-pair">
                <div class="control-group">
                    <label style="width: 60px;">N (cols):</label>
                    <input type="range" id="nSlider" min="1" max="500" value="16">
                    <input type="number" id="nInput" min="1" max="500" value="16" class="num-input">
                </div>
                <div class="control-group">
                    <label style="width: 60px;">M (rows):</label>
                    <input type="range" id="mSlider" min="1" max="500" value="16">
                    <input type="number" id="mInput" min="1" max="500" value="16" class="num-input">
                </div>
            </div>
            <button class="icon-btn active" id="resolutionLock" title="Lock N:M ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Aspect:</label>
            <button class="icon-btn active" id="aspectLock" title="Lock rectangle aspect ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Grid Opacity:</label>
            <div class="btn-group" id="opacityBtns">
                <button class="btn" data-value="0">0%</button>
                <button class="btn" data-value="50">50%</button>
                <button class="btn active" data-value="100">100%</button>
            </div>
        </div>
        <div class="control-group">
            <label>Sample:</label>
            <div class="btn-group" id="sampleBtns">
                <button class="btn active" data-value="center">Center</button>
                <button class="btn" data-value="mean">Mean</button>
                <button class="btn" data-value="median">Median</button>
            </div>
        </div>
        <div class="control-group">
            <label>Expand:</label>
            <button class="icon-btn" id="expandMode" title="Expand mode: resize by adding/removing cells">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="currentColor">
                    <rect x="1" y="1" width="5" height="5" rx="1"/>
                    <rect x="7" y="1" width="5" height="5" rx="1"/>
                    <rect x="1" y="7" width="5" height="5" rx="1"/>
                    <rect x="7" y="7" width="5" height="5" rx="1" opacity="0.4"/>
                    <rect x="13" y="7" width="4" height="5" rx="1" opacity="0.4"/>
                    <rect x="7" y="13" width="5" height="4" rx="1" opacity="0.4"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Tiles:</label>
            <div class="btn-group" id="tileBtns">
                <button class="btn active" data-value="square" title="Square tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><rect x="1" y="1" width="12" height="12"/></svg>
                </button>
                <button class="btn" data-value="hex" title="Flat-top hexagon (H)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M4 1H10L13 7L10 13H4L1 7L4 1Z"/></svg>
                </button>
                <button class="btn" data-value="hexV" title="Pointy-top hexagon">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 0.5L13 4V10L7 13.5L1 10V4L7 0.5Z"/></svg>
                </button>
                <button class="btn" data-value="tri" title="Triangle tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 1L13 13H1L7 1Z"/></svg>
                </button>
            </div>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <span class="iconify" data-icon="mdi:undo" data-width="20"></span>
            </button>
            <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <span class="iconify" data-icon="mdi:redo" data-width="20"></span>
            </button>
        </div>
        <div class="control-group">
            <button class="btn" id="resetBtn">Reset Grid</button>
        </div>
        <div class="control-group">
            <button class="btn accent" id="saveBtn">Save PNG</button>
            <button class="btn accent" id="saveSvgBtn">Save SVG</button>
        </div>
        <div class="control-group">
            <input type="text" id="infoField" readonly title="Click to copy">
        </div>
        <div class="control-group">
            <label>Grid:</label>
            <div class="color-swatch" id="gridColorSwatch" title="Grid/border color">
                <div class="color-swatch-inner" id="gridColorSwatchInner" style="background:#e94560"></div>
            </div>
            <input type="color" id="gridColorPicker" class="color-picker-hidden" value="#e94560">
        </div>
        <div class="control-group chroma-group">
            <label>Chroma:</label>
            <button class="icon-btn" id="chromaToggle" title="Enable chroma key">
                <span class="iconify" data-icon="mdi:eye-off" data-width="18"></span>
            </button>
            <div class="color-swatch" id="chromaSwatch" title="Click to pick color">
                <div class="color-swatch-inner" id="chromaSwatchInner"></div>
            </div>
            <input type="color" id="chromaColorPicker" class="color-picker-hidden" value="#00ff00">
            <button class="icon-btn" id="eyedropperBtn" title="Pick color from image (E)">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <input type="range" id="chromaTolerance" min="0" max="150" value="30" class="chroma-slider" title="Color tolerance">
            <span id="chromaToleranceVal" style="min-width: 25px; font-size: 12px; color: #e94560;">30</span>
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <div id="canvasWrapper">
            <svg id="mainSvg"></svg>
        </div>
        <div class="drop-zone show-initial" id="dropZone">
            <p>Drop an image here</p>
        </div>
    </div>

    <div class="instructions">
        Drag corners to resize the pixel grid. Drag inside to move it. Use sliders to change grid dimensions.
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const mainSvg = $('mainSvg');
        const container = $('canvasContainer');
        const wrapper = $('canvasWrapper');
        const dropZone = $('dropZone');
        const nSlider = $('nSlider'), mSlider = $('mSlider');
        const nInput = $('nInput'), mInput = $('mInput');

        // Global constants
        const MAX_GRID = 500;
        const MAX_UNDO = 50;
        const DEFAULT_N = 16, DEFAULT_M = 16;
        const DEFAULT_RECT_SIZE = 200;
        const MIN_RECT_SIZE = 20;
        const RETINA = window.devicePixelRatio || 1;

        let image = null;
        let gridOpacity = 1;
        let sampleMode = 'center';
        let rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
        let dragging = null;
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, width: 0, height: 0 };
        let nStart = DEFAULT_N, mStart = DEFAULT_M;

        let undoStack = [], redoStack = [];

        let aspectLocked = true, lockedAspectRatio = 1;
        let resolutionLocked = true, expandModeOn = false;

        // Chroma key state
        let chromaEnabled = false;
        let chromaColor = [0, 255, 0]; // RGB
        let chromaTolerance = 30;
        let eyedropperMode = false;
        let tileMode = 'square'; // 'square', 'hex', 'hexV', 'tri'
        let gridColor = [233, 69, 96]; // RGB for #e94560

        // View transform state (pan/zoom for the whole canvas view)
        let viewOffset = { x: 0, y: 0 };
        let viewZoom = 1;

        // === HELPER FUNCTIONS ===
        function update() { render(); autoSave(); }

        function setBtnGroupValue(groupId, value) {
            $(groupId).querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value == value));
        }

        function setChromaEnabled(enabled) {
            chromaEnabled = enabled;
            $('chromaToggle').classList.toggle('active', enabled);
            $('chromaToggle').querySelector('.iconify').dataset.icon = enabled ? 'mdi:eye' : 'mdi:eye-off';
            updateChromaSwatch();
        }

        function setEyedropperMode(enabled) {
            eyedropperMode = enabled;
            $('eyedropperBtn').classList.toggle('active', enabled);
            mainSvg.style.cursor = enabled ? 'crosshair' : 'default';
        }

        function setLockState(btnId, locked) {
            const btn = $(btnId);
            btn.classList.toggle('active', locked);
            btn.querySelector('svg').innerHTML = locked ? LOCK_CLOSED : LOCK_OPEN;
        }

        function aggregatePixels(pixels) {
            if (!pixels.length) return null;
            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            return medianColor(pixels);
        }

        function colorToFill(color, nullValue = null) {
            if (!color) return nullValue;
            if (chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance) {
                return nullValue;
            }
            return `rgb(${color[0]|0},${color[1]|0},${color[2]|0})`;
        }

        // Geometry formulas for each tile mode
        const TILE_GEOMETRY = {
            hex:    { wF: n => n * 0.75 + 0.25, hF: m => m + 0.5,        snapW: 0.75, snapH: 1 },
            hexV:   { wF: n => n + 0.5,         hF: m => m * 0.75 + 0.25, snapW: 1,    snapH: 0.75 },
            tri:    { wF: n => (n + 1) / 2,     hF: m => m,              snapW: 0.5,  snapH: 1 },
            square: { wF: n => n,               hF: m => m,              snapW: 1,    snapH: 1 }
        };

        // Lock icon SVG paths (moved up for setLockState)
        const LOCK_CLOSED = '<path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';
        const LOCK_OPEN = '<path d="M12 8h-2V6a2 2 0 10-4 0v2H4V6a4 4 0 118 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';

        // Color picker with undo tracking
        function setupColorPicker(swatchId, pickerId, getColor, setColor, onUpdate) {
            let undoPushed = false;
            $(swatchId).addEventListener('click', () => {
                $(pickerId).value = rgbToHex(getColor());
                $(pickerId).click();
            });
            $(pickerId).addEventListener('input', e => {
                if (!undoPushed) { pushUndo(); undoPushed = true; }
                setColor(hexToRgb(e.target.value));
                if (onUpdate) onUpdate();
                update();
            });
            $(pickerId).addEventListener('change', () => { undoPushed = false; });
        }

        // Helper to set up exclusive button groups
        function setupBtnGroup(containerId, onChange) {
            const container = $(containerId);
            container.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    onChange(btn.dataset.value);
                    update();
                });
            });
        }

        setupBtnGroup('opacityBtns', val => { pushUndo(); gridOpacity = parseInt(val) / 100; });
        setupBtnGroup('sampleBtns', val => { pushUndo(); sampleMode = val; });

        // Unified slider/input handling
        function syncNM(source, newVal) {
            newVal = Math.min(Math.max(1, newVal || 1), MAX_GRID);
            if (source === 'n') {
                nSlider.value = nInput.value = newVal;
                if (resolutionLocked) mSlider.value = mInput.value = newVal;
            } else {
                mSlider.value = mInput.value = newVal;
                if (resolutionLocked) nSlider.value = nInput.value = newVal;
            }
            update();
        }

        nSlider.addEventListener('input', () => syncNM('n', parseInt(nSlider.value)));
        mSlider.addEventListener('input', () => syncNM('m', parseInt(mSlider.value)));
        nInput.addEventListener('input', () => syncNM('n', parseInt(nInput.value)));
        mInput.addEventListener('input', () => syncNM('m', parseInt(mInput.value)));

        function setupToggle(btnId, getter, setter, useLockIcon = false) {
            const btn = $(btnId);
            btn.addEventListener('click', () => {
                const newVal = !getter();
                setter(newVal);
                btn.classList.toggle('active', newVal);
                if (useLockIcon) setLockState(btnId, newVal);
                autoSave();
            });
        }

        setupToggle('aspectLock', () => aspectLocked, v => { pushUndo(); aspectLocked = v; if (v) lockedAspectRatio = rect.width / rect.height; }, true);
        setupToggle('resolutionLock', () => resolutionLocked, v => { pushUndo(); resolutionLocked = v; }, true);
        setupToggle('expandMode', () => expandModeOn, v => { pushUndo(); expandModeOn = v; });

        setupBtnGroup('tileBtns', val => { pushUndo(); tileMode = val; update(); });

        // Color conversion helpers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 255, 0];
        }

        function rgbToHex([r, g, b]) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Chroma key controls
        function updateChromaSwatch() {
            const [r, g, b] = chromaColor;
            $('chromaSwatchInner').style.background = chromaEnabled ? `rgb(${r},${g},${b})` : 'transparent';
            $('chromaSwatch').style.borderColor = chromaEnabled ? '#e94560' : '#888';
        }

        $('chromaToggle').addEventListener('click', () => {
            pushUndo();
            setChromaEnabled(!chromaEnabled);
            update();
        });

        setupColorPicker('chromaSwatch', 'chromaColorPicker', () => chromaColor, c => {
            chromaColor = c;
            if (!chromaEnabled) setChromaEnabled(true);
            updateChromaSwatch();
        });

        $('eyedropperBtn').addEventListener('click', () => setEyedropperMode(!eyedropperMode));

        let toleranceUndoPushed = false;
        $('chromaTolerance').addEventListener('mousedown', () => { pushUndo(); toleranceUndoPushed = true; });
        $('chromaTolerance').addEventListener('input', e => {
            chromaTolerance = parseInt(e.target.value);
            $('chromaToleranceVal').textContent = chromaTolerance;
            update();
        });
        $('chromaTolerance').addEventListener('mouseup', () => { toleranceUndoPushed = false; });

        updateChromaSwatch();

        // Grid color controls
        function updateGridColorSwatch() {
            $('gridColorSwatchInner').style.background = `rgb(${gridColor.join(',')})`;
        }

        setupColorPicker('gridColorSwatch', 'gridColorPicker', () => gridColor, c => {
            gridColor = c;
            updateGridColorSwatch();
        });

        updateGridColorSwatch();

        // State helpers - used by undo/redo and localStorage
        function getState() {
            return { rect: { ...rect }, n: parseInt(nSlider.value), m: parseInt(mSlider.value),
                gridOpacity, sampleMode, aspectLocked, lockedAspectRatio, resolutionLocked, expandModeOn,
                nMax: parseInt(nSlider.max), mMax: parseInt(mSlider.max),
                chromaEnabled, chromaColor, chromaTolerance, tileMode, gridColor };
        }

        function applyState(s) {
            rect = { ...s.rect };
            nSlider.max = mSlider.max = Math.min(s.nMax || 500, 500);
            nSlider.value = nInput.value = Math.min(s.n || 16, 500);
            mSlider.value = mInput.value = Math.min(s.m || 16, 500);
            gridOpacity = s.gridOpacity ?? 0.5;
            sampleMode = s.sampleMode ?? 'center';
            aspectLocked = s.aspectLocked ?? true;
            lockedAspectRatio = s.lockedAspectRatio ?? 1;
            resolutionLocked = s.resolutionLocked ?? true;
            expandModeOn = s.expandModeOn ?? false;
            chromaEnabled = s.chromaEnabled ?? false;
            chromaColor = s.chromaColor ?? [0, 255, 0];
            chromaTolerance = s.chromaTolerance ?? 30;
            tileMode = s.tileMode ?? (s.hexMode ? 'hex' : 'square'); // backwards compat
            gridColor = s.gridColor ?? [233, 69, 96];

            // Update UI
            updateGridColorSwatch();
            setBtnGroupValue('opacityBtns', Math.round(gridOpacity * 100));
            setBtnGroupValue('sampleBtns', sampleMode);
            setBtnGroupValue('tileBtns', tileMode);
            setLockState('aspectLock', aspectLocked);
            setLockState('resolutionLock', resolutionLocked);
            $('expandMode').classList.toggle('active', expandModeOn);
            setChromaEnabled(chromaEnabled);
            $('chromaTolerance').value = chromaTolerance;
            $('chromaToleranceVal').textContent = chromaTolerance;
        }

        // Undo/redo
        function pushUndo() { undoStack.push(JSON.stringify(getState())); if (undoStack.length > MAX_UNDO) undoStack.shift(); redoStack = []; }
        function undo() { if (!undoStack.length) return; redoStack.push(JSON.stringify(getState())); applyState(JSON.parse(undoStack.pop())); render(); }
        function redo() { if (!redoStack.length) return; undoStack.push(JSON.stringify(getState())); applyState(JSON.parse(redoStack.pop())); render(); }

        $('undoBtn').addEventListener('click', undo);
        $('redoBtn').addEventListener('click', redo);

        // LocalStorage
        function autoSave() {
            localStorage.setItem('pixelArtToolState', JSON.stringify(getState()));
            if (image) {
                const tc = document.createElement('canvas');
                tc.width = image.width; tc.height = image.height;
                tc.getContext('2d').drawImage(image, 0, 0);
                localStorage.setItem('pixelArtToolImage', tc.toDataURL('image/png'));
            }
        }

        function loadFromLocalStorage() {
            const stateJson = localStorage.getItem('pixelArtToolState');
            const imageData = localStorage.getItem('pixelArtToolImage');
            if (imageData) {
                const img = new Image();
                img.onload = () => { image = img; imageSrc = imageData; resizeView(); dropZone.classList.remove('show-initial'); if (stateJson) applyState(JSON.parse(stateJson)); render(); };
                img.src = imageData;
            } else if (stateJson) applyState(JSON.parse(stateJson));
        }

        // Color sampling
        function sampleCell(imgData, x0, y0, x1, y1, width) {
            x0 = Math.max(0, Math.floor(x0)); y0 = Math.max(0, Math.floor(y0));
            x1 = Math.min(width, Math.floor(x1)); y1 = Math.min(imgData.height, Math.floor(y1));
            if (x1 <= x0 || y1 <= y0) return null;

            if (sampleMode === 'center') {
                const idx = (Math.floor((y0 + y1) / 2) * width + Math.floor((x0 + x1) / 2)) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                const idx = (y * width + x) * 4;
                pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
            }
            return aggregatePixels(pixels);
        }

        // Info field
        function updateInfoField() {
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            $('infoField').value = `x=${rect.x.toFixed(1)} y=${rect.y.toFixed(1)} w=${rect.width.toFixed(1)} h=${rect.height.toFixed(1)} n=${n} m=${m}`;
        }
        $('infoField').addEventListener('click', function() { this.select(); navigator.clipboard.writeText(this.value); });

        // Save PNG
        $('saveBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const outCanvas = document.createElement('canvas');
            outCanvas.width = n; outCanvas.height = m;
            const outCtx = outCanvas.getContext('2d');

            const imgData = getImageData();

            const cellW = rect.width / n, cellH = rect.height / m;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                const color = sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, image.width);
                if (color) {
                    // Apply chroma key to saved image (hard threshold)
                    const alpha = chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance ? 0 : 1;
                    outCtx.fillStyle = `rgba(${color.map(Math.round).join(',')},${alpha})`;
                    outCtx.fillRect(col, row, 1, 1);
                }
            }

            const link = document.createElement('a');
            link.download = `pixel_art_x${rect.x.toFixed(0)}_y${rect.y.toFixed(0)}_w${rect.width.toFixed(0)}_h${rect.height.toFixed(0)}_n${n}_m${m}.png`;
            link.href = outCanvas.toDataURL('image/png');
            link.click();
        });

        // Save SVG - preserves exact tile geometry
        $('saveSvgBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const imgData = getImageData();
            const svgW = 800, svgH = 800 * (rect.height / rect.width);
            const scaleX = svgW / rect.width, scaleY = svgH / rect.height;
            let paths = '';
            const scalePts = pts => pts.map(([x, y]) => `${(x * scaleX).toFixed(2)},${(y * scaleY).toFixed(2)}`).join(' ');

            if (tileMode === 'hex') {
                const { hexW, hexH, halfW, halfH } = getHexGeometry(n, m, rect.width, rect.height);
                for (let col = 0; col < n; col++) for (let row = 0; row < m; row++) {
                    const { x: cx, y: cy } = getHexCenter(col, row, hexW, hexH, 0, 0);
                    const fill = colorToFill(sampleHexCell(imgData, rect.x + cx, rect.y + cy, halfW, halfH, image.width, image.height));
                    if (fill) paths += `<polygon points="${scalePts([[cx + halfW, cy], [cx + halfW * 0.5, cy - halfH], [cx - halfW * 0.5, cy - halfH], [cx - halfW, cy], [cx - halfW * 0.5, cy + halfH], [cx + halfW * 0.5, cy + halfH]])}" fill="${fill}"/>\n`;
                }
            } else if (tileMode === 'hexV') {
                const { hexW, hexH, halfW, halfH } = getHexVGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const { x: cx, y: cy } = getHexVCenter(col, row, hexW, hexH, 0, 0);
                    const fill = colorToFill(sampleHexVCell(imgData, rect.x + cx, rect.y + cy, halfW, halfH, image.width, image.height));
                    if (fill) paths += `<polygon points="${scalePts([[cx, cy - halfH], [cx + halfW, cy - halfH * 0.5], [cx + halfW, cy + halfH * 0.5], [cx, cy + halfH], [cx - halfW, cy + halfH * 0.5], [cx - halfW, cy - halfH * 0.5]])}" fill="${fill}"/>\n`;
                }
            } else if (tileMode === 'tri') {
                const { triW, triH } = getTriGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const tri = getTriVertices(col, row, triW, triH, 0, 0);
                    const fill = colorToFill(sampleTriCell(imgData, { ...tri, cx: rect.x + tri.cx, cy: rect.y + tri.cy, x0: rect.x + tri.x0, y0: rect.y + tri.y0, x1: rect.x + tri.x1, y1: rect.y + tri.y1, x2: rect.x + tri.x2, y2: rect.y + tri.y2 }, image.width, image.height));
                    if (fill) paths += `<polygon points="${scalePts([[tri.x0, tri.y0], [tri.x1, tri.y1], [tri.x2, tri.y2]])}" fill="${fill}"/>\n`;
                }
            } else {
                const cellW = rect.width / n, cellH = rect.height / m;
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const fill = colorToFill(sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, image.width));
                    if (fill) paths += `<rect x="${(col * cellW * scaleX).toFixed(2)}" y="${(row * cellH * scaleY).toFixed(2)}" width="${(cellW * scaleX).toFixed(2)}" height="${(cellH * scaleY).toFixed(2)}" fill="${fill}"/>\n`;
                }
            }

            const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${svgW.toFixed(0)}" height="${svgH.toFixed(0)}" viewBox="0 0 ${svgW.toFixed(0)} ${svgH.toFixed(0)}">\n${paths}</svg>`;
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `pixel_art_${tileMode}_n${n}_m${m}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        });

        // Reset
        $('resetBtn').addEventListener('click', () => {
            nSlider.value = nInput.value = DEFAULT_N;
            mSlider.value = mInput.value = DEFAULT_M;
            if (image) { rect.width = rect.height = DEFAULT_RECT_SIZE; rect.x = (image.width - DEFAULT_RECT_SIZE) / 2; rect.y = (image.height - DEFAULT_RECT_SIZE) / 2; }
            else rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
            aspectLocked = false;
            setLockState('aspectLock', false);
            lockedAspectRatio = 1;
            update();
        });

        // Drag and drop
        container.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('active'); });
        container.addEventListener('dragleave', e => { if (!container.contains(e.relatedTarget)) dropZone.classList.remove('active'); });
        container.addEventListener('drop', e => {
            e.preventDefault(); dropZone.classList.remove('active', 'show-initial');
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('image/')) loadImage(file);
        });

        let imageSrc = null; // data URL for the image

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    imageSrc = e.target.result;
                    resizeView();
                    update();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        let canvasScale = 1; // scale from image coords to display coords

        function resizeView() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            canvasScale = Math.min((cr.width - 40) / image.width, (cr.height - 40) / image.height, 1);
            updateView();
        }

        function updateView() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            // Calculate viewBox for pan/zoom (SVG re-renders at full res)
            const vbW = image.width / viewZoom;
            const vbH = image.height / viewZoom;
            const vbX = -viewOffset.x / (canvasScale * viewZoom);
            const vbY = -viewOffset.y / (canvasScale * viewZoom);
            mainSvg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
            // Size SVG to fill container
            mainSvg.style.width = cr.width + 'px';
            mainSvg.style.height = cr.height + 'px';
            wrapper.style.transform = '';
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2);
        }

        function medianColor(pixels) {
            const half = pixels.length >> 1;
            return [0, 1, 2].map(i => {
                const bins = new Uint32Array(256);
                for (const p of pixels) bins[p[i]]++;
                let sum = 0;
                for (let v = 0; v < 256; v++) { sum += bins[v]; if (sum > half) return v; }
                return 255;
            });
        }

        // Hexagon helper functions - stretched to fit grid
        function getHexGeometry(n, m, rectW, rectH) {
            // Calculate hex dimensions to perfectly tile the rect
            // Flat-top hex: horizontal spacing = 1.5 * hexW, vertical spacing = hexH (with 0.5 offset for odd cols)
            const hexW = rectW / (n * 0.75 + 0.25);
            const hexH = rectH / (m + 0.5);
            return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
        }

        function getHexCenter(col, row, hexW, hexH, offsetX, offsetY) {
            // Flat-top hexagon layout (offset odd columns)
            const x = offsetX + col * hexW * 0.75 + hexW / 2;
            const y = offsetY + row * hexH + (col % 2 === 1 ? hexH / 2 : 0) + hexH / 2;
            return { x, y };
        }

        function pointInHex(px, py, cx, cy, halfW, halfH) {
            // Check if point is inside stretched hexagon
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            // Check against slanted edges: the hex edge goes from (halfW, 0) to (halfW/2, halfH)
            return halfH * halfW - halfH * dx - halfW * 0.5 * dy >= 0;
        }

        function sampleHexCell(imgData, cx, cy, halfW, halfH, width, height) {
            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
            }
            const x0 = Math.max(0, Math.floor(cx - halfW)), y0 = Math.max(0, Math.floor(cy - halfH));
            const x1 = Math.min(width, Math.ceil(cx + halfW)), y1 = Math.min(height, Math.ceil(cy + halfH));
            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                if (pointInHex(x + 0.5, y + 0.5, cx, cy, halfW, halfH)) {
                    const idx = (y * width + x) * 4;
                    pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                }
            }
            return aggregatePixels(pixels);
        }

        // Pointy-top hexagon helpers
        function getHexVGeometry(n, m, rectW, rectH) {
            // Pointy-top hex: vertical spacing = 1.5 * hexH, horizontal spacing = hexW (with 0.5 offset for odd rows)
            const hexW = rectW / (n + 0.5);
            const hexH = rectH / (m * 0.75 + 0.25);
            return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
        }

        function getHexVCenter(col, row, hexW, hexH, offsetX, offsetY) {
            // Pointy-top hexagon layout (offset odd rows)
            const x = offsetX + col * hexW + (row % 2 === 1 ? hexW / 2 : 0) + hexW / 2;
            const y = offsetY + row * hexH * 0.75 + hexH / 2;
            return { x, y };
        }

        function pointInHexV(px, py, cx, cy, halfW, halfH) {
            // Check if point is inside stretched pointy-top hexagon
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            // Check against slanted edges: the hex edge goes from (0, halfH) to (halfW, halfH/2)
            return halfW * halfH - halfW * dy - halfH * 0.5 * dx >= 0;
        }

        function sampleHexVCell(imgData, cx, cy, halfW, halfH, width, height) {
            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
            }
            const x0 = Math.max(0, Math.floor(cx - halfW)), y0 = Math.max(0, Math.floor(cy - halfH));
            const x1 = Math.min(width, Math.ceil(cx + halfW)), y1 = Math.min(height, Math.ceil(cy + halfH));
            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                if (pointInHexV(x + 0.5, y + 0.5, cx, cy, halfW, halfH)) {
                    const idx = (y * width + x) * 4;
                    pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                }
            }
            return aggregatePixels(pixels);
        }

        // Triangle helper functions
        function getTriGeometry(n, m, rectW, rectH) {
            // n = columns of triangles (alternating up/down), m = rows
            // Each pair of triangles (up+down) spans one "cell width"
            const triW = rectW / ((n + 1) / 2);
            const triH = rectH / m;
            return { triW, triH };
        }

        function getTriVertices(col, row, triW, triH, offsetX, offsetY) {
            // Alternating up/down triangles that perfectly tessellate
            const isUp = (col + row) % 2 === 0;
            const baseX = offsetX + col * triW / 2;
            const baseY = offsetY + row * triH;

            if (isUp) {
                // Point at top
                return {
                    x0: baseX + triW / 2, y0: baseY,
                    x1: baseX, y1: baseY + triH,
                    x2: baseX + triW, y2: baseY + triH,
                    cx: baseX + triW / 2, cy: baseY + triH * 2 / 3
                };
            } else {
                // Point at bottom
                return {
                    x0: baseX, y0: baseY,
                    x1: baseX + triW, y1: baseY,
                    x2: baseX + triW / 2, y2: baseY + triH,
                    cx: baseX + triW / 2, cy: baseY + triH / 3
                };
            }
        }

        function pointInTriangle(px, py, x0, y0, x1, y1, x2, y2) {
            const area = 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2);
            const s = 1 / (2 * area) * (y0 * x2 - x0 * y2 + (y2 - y0) * px + (x0 - x2) * py);
            const t = 1 / (2 * area) * (x0 * y1 - y0 * x1 + (y0 - y1) * px + (x1 - x0) * py);
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }

        function sampleTriCell(imgData, tri, width, height) {
            const { x0, y0, x1, y1, x2, y2, cx, cy } = tri;
            if (sampleMode === 'center') {
                const idx = (Math.floor(cy) * width + Math.floor(cx)) * 4;
                return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
            }
            const minX = Math.max(0, Math.floor(Math.min(x0, x1, x2))), maxX = Math.min(width, Math.ceil(Math.max(x0, x1, x2)));
            const minY = Math.max(0, Math.floor(Math.min(y0, y1, y2))), maxY = Math.min(height, Math.ceil(Math.max(y0, y1, y2)));
            const pixels = [];
            for (let y = minY; y < maxY; y++) for (let x = minX; x < maxX; x++) {
                if (pointInTriangle(x + 0.5, y + 0.5, x0, y0, x1, y1, x2, y2)) {
                    const idx = (y * width + x) * 4;
                    pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                }
            }
            return aggregatePixels(pixels);
        }

        // Cache image data to avoid recreating every frame
        let cachedImgData = null;
        let cachedImgDataSrc = null;

        function getImageData() {
            if (cachedImgDataSrc === image.src) return cachedImgData;
            const sampleCanvas = document.createElement('canvas');
            sampleCanvas.width = image.width;
            sampleCanvas.height = image.height;
            const sampleCtx = sampleCanvas.getContext('2d');
            sampleCtx.drawImage(image, 0, 0);
            cachedImgData = sampleCtx.getImageData(0, 0, image.width, image.height);
            cachedImgDataSrc = image.src;
            return cachedImgData;
        }

        // Persistent SVG elements
        let svgElements = { image: null, tiles: null, border: null, handles: [] };
        let lastTileKey = '';

        function initSvgElements() {
            const ns = 'http://www.w3.org/2000/svg';
            mainSvg.innerHTML = '';

            svgElements.image = document.createElementNS(ns, 'image');
            mainSvg.appendChild(svgElements.image);

            svgElements.tiles = document.createElementNS(ns, 'g');
            mainSvg.appendChild(svgElements.tiles);

            svgElements.border = document.createElementNS(ns, 'rect');
            svgElements.border.setAttribute('fill', 'none');
            svgElements.border.setAttribute('vector-effect', 'non-scaling-stroke');
            svgElements.border.setAttribute('stroke-width', '2');
            mainSvg.appendChild(svgElements.border);

            svgElements.handles = [];
            for (let i = 0; i < 4; i++) {
                const h = document.createElementNS(ns, 'rect');
                svgElements.handles.push(h);
                mainSvg.appendChild(h);
            }
        }

        let renderPending = false;
        function render() {
            if (!image || renderPending) return;
            renderPending = true;
            requestAnimationFrame(() => {
                renderPending = false;
                renderNow();
            });
        }

        function renderNow() {
            if (!image) return;
            if (!svgElements.image) initSvgElements();

            const imgData = getImageData();
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const fastMode = dragging !== null;
            const gridColorRgba = `rgba(${gridColor.join(',')},0.5)`;
            const gridColorRgb = `rgb(${gridColor.join(',')})`;

            // Update image
            if (svgElements.image.getAttribute('href') !== imageSrc) {
                svgElements.image.setAttribute('href', imageSrc);
                svgElements.image.setAttribute('width', image.width);
                svgElements.image.setAttribute('height', image.height);
            }

            // Check if tiles need rebuild (structure changed)
            const tileKey = `${n},${m},${tileMode}`;
            const structureChanged = tileKey !== lastTileKey;

            if (structureChanged) {
                // Rebuild tile elements
                const ns = 'http://www.w3.org/2000/svg';
                svgElements.tiles.innerHTML = '';
                const totalTiles = n * m;
                const isSquare = tileMode === 'square';
                for (let i = 0; i < totalTiles; i++) {
                    const el = document.createElementNS(ns, isSquare ? 'rect' : 'polygon');
                    el.setAttribute('vector-effect', 'non-scaling-stroke');
                    el.setAttribute('stroke-width', '1');
                    svgElements.tiles.appendChild(el);
                }
                lastTileKey = tileKey;
            }

            // Update tile attributes
            const tiles = svgElements.tiles.children;
            const cellW = rect.width / n, cellH = rect.height / m;

            function sampleCenter(cx, cy) {
                const px = Math.floor(cx), py = Math.floor(cy);
                if (px < 0 || px >= image.width || py < 0 || py >= image.height) return null;
                const idx = (py * image.width + px) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            }

            function setTileStyle(el, fill) {
                el.setAttribute('fill', fill || 'none');
                el.setAttribute('fill-opacity', gridOpacity);
                el.setAttribute('stroke', gridColorRgba);
            }

            let idx = 0;
            if (tileMode === 'hex') {
                const { hexW, hexH, halfW, halfH } = getHexGeometry(n, m, rect.width, rect.height);
                for (let col = 0; col < n; col++) for (let row = 0; row < m; row++) {
                    const { x: cx, y: cy } = getHexCenter(col, row, hexW, hexH, rect.x, rect.y);
                    const el = tiles[idx++];
                    el.setAttribute('points', `${cx + halfW},${cy} ${cx + halfW * 0.5},${cy - halfH} ${cx - halfW * 0.5},${cy - halfH} ${cx - halfW},${cy} ${cx - halfW * 0.5},${cy + halfH} ${cx + halfW * 0.5},${cy + halfH}`);
                    setTileStyle(el, colorToFill(fastMode ? sampleCenter(cx, cy) : sampleHexCell(imgData, cx, cy, halfW, halfH, image.width, image.height), 'transparent'));
                }
            } else if (tileMode === 'hexV') {
                const { hexW, hexH, halfW, halfH } = getHexVGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const { x: cx, y: cy } = getHexVCenter(col, row, hexW, hexH, rect.x, rect.y);
                    const el = tiles[idx++];
                    el.setAttribute('points', `${cx},${cy - halfH} ${cx + halfW},${cy - halfH * 0.5} ${cx + halfW},${cy + halfH * 0.5} ${cx},${cy + halfH} ${cx - halfW},${cy + halfH * 0.5} ${cx - halfW},${cy - halfH * 0.5}`);
                    setTileStyle(el, colorToFill(fastMode ? sampleCenter(cx, cy) : sampleHexVCell(imgData, cx, cy, halfW, halfH, image.width, image.height), 'transparent'));
                }
            } else if (tileMode === 'tri') {
                const { triW, triH } = getTriGeometry(n, m, rect.width, rect.height);
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const tri = getTriVertices(col, row, triW, triH, rect.x, rect.y);
                    const el = tiles[idx++];
                    el.setAttribute('points', `${tri.x0},${tri.y0} ${tri.x1},${tri.y1} ${tri.x2},${tri.y2}`);
                    setTileStyle(el, colorToFill(fastMode ? sampleCenter(tri.cx, tri.cy) : sampleTriCell(imgData, tri, image.width, image.height), 'transparent'));
                }
            } else {
                for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                    const x = rect.x + col * cellW, y = rect.y + row * cellH;
                    const el = tiles[idx++];
                    el.setAttribute('x', x);
                    el.setAttribute('y', y);
                    el.setAttribute('width', cellW);
                    el.setAttribute('height', cellH);
                    setTileStyle(el, colorToFill(fastMode ? sampleCenter(x + cellW / 2, y + cellH / 2) : sampleCell(imgData, x, y, x + cellW, y + cellH, image.width), 'transparent'));
                }
            }

            // Update border
            svgElements.border.setAttribute('x', rect.x);
            svgElements.border.setAttribute('y', rect.y);
            svgElements.border.setAttribute('width', rect.width);
            svgElements.border.setAttribute('height', rect.height);
            svgElements.border.setAttribute('stroke', gridColorRgb);

            // Update handles (size compensates for zoom so they appear constant on screen)
            const hsZoom = getHandleSizeHit();
            [[0, 0], [1, 0], [0, 1], [1, 1]].forEach(([cx, cy], i) => {
                const h = svgElements.handles[i];
                h.setAttribute('x', rect.x + cx * rect.width - hsZoom / 2);
                h.setAttribute('y', rect.y + cy * rect.height - hsZoom / 2);
                h.setAttribute('width', hsZoom);
                h.setAttribute('height', hsZoom);
                h.setAttribute('fill', gridColorRgb);
            });

            updateView();
            updateInfoField();
        }

        function getMousePos(e) {
            // Use SVG's built-in coordinate transform (accounts for viewBox and preserveAspectRatio)
            const pt = mainSvg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgPt = pt.matrixTransform(mainSvg.getScreenCTM().inverse());
            return { x: svgPt.x, y: svgPt.y };
        }

        // Handle size in image coords (compensates for zoom so handles appear constant on screen)
        const HANDLE_SCREEN_PX = 12;
        function getHandleSizeHit() {
            return HANDLE_SCREEN_PX / (canvasScale * viewZoom);
        }

        function getHitZone(pos) {
            const hs = getHandleSizeHit();
            const corners = [['tl', 0, 0], ['tr', 1, 0], ['bl', 0, 1], ['br', 1, 1]];
            for (const [id, cx, cy] of corners) {
                if (Math.abs(pos.x - (rect.x + cx * rect.width)) < hs && Math.abs(pos.y - (rect.y + cy * rect.height)) < hs) return id;
            }
            const inX = pos.x > rect.x && pos.x < rect.x + rect.width;
            const inY = pos.y > rect.y && pos.y < rect.y + rect.height;
            if (Math.abs(pos.x - rect.x) < hs && inY) return 'left';
            if (Math.abs(pos.x - rect.x - rect.width) < hs && inY) return 'right';
            if (Math.abs(pos.y - rect.y) < hs && inX) return 'top';
            if (Math.abs(pos.y - rect.y - rect.height) < hs && inX) return 'bottom';
            if (inX && inY) return 'move';
            return null;
        }

        const CURSORS = { tl: 'nwse-resize', br: 'nwse-resize', tr: 'nesw-resize', bl: 'nesw-resize', left: 'ew-resize', right: 'ew-resize', top: 'ns-resize', bottom: 'ns-resize', move: 'move' };

        mainSvg.addEventListener('mousedown', e => {
            const pos = getMousePos(e);

            // Eyedropper mode - pick color from image
            if (eyedropperMode && image) {
                const imgData = getImageData();
                const px = Math.floor(pos.x), py = Math.floor(pos.y);
                if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
                    const idx = (py * image.width + px) * 4;
                    chromaColor = [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                    $('chromaColorPicker').value = rgbToHex(chromaColor);
                    if (!chromaEnabled) setChromaEnabled(true);
                    updateChromaSwatch();
                }
                setEyedropperMode(false);
                update();
                return;
            }

            dragging = getHitZone(pos);
            if (dragging) {
                pushUndo();
                dragStart = pos;
                rectStart = { ...rect };
                nStart = parseInt(nSlider.value);
                mStart = parseInt(mSlider.value);
                if (aspectLocked) lockedAspectRatio = rect.width / rect.height;
            }
        });

        mainSvg.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            mainSvg.style.cursor = eyedropperMode ? 'crosshair' : (CURSORS[getHitZone(pos)] || 'default');
        });

        window.addEventListener('mousemove', e => {
            if (!dragging) return;

            const pos = getMousePos(e);
            let dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            if (e.shiftKey) { dx /= 10; dy /= 10; }
            if (e.ctrlKey || e.metaKey) { if (Math.abs(dx) > Math.abs(dy)) dy = 0; else dx = 0; }

            if (dragging === 'move') {
                let newX = rectStart.x + dx, newY = rectStart.y + dy;
                if (expandModeOn && !e.shiftKey) {
                    // Snap relative to original position based on tile geometry
                    const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);
                    const snappedDx = Math.round(dx / snap.dx) * snap.dx;
                    const snappedDy = Math.round(dy / snap.dy) * snap.dy;
                    newX = rectStart.x + snappedDx;
                    newY = rectStart.y + snappedDy;
                }
                rect.x = newX; rect.y = newY;
            } else if (expandModeOn) {
                handleExpandResize(dx, dy);
            } else {
                // Edges always use free resize (axis-locked), corners use aspect resize if locked
                const isEdge = ['left', 'right', 'top', 'bottom'].includes(dragging);
                if (aspectLocked && !isEdge) {
                    handleAspectResize(dx, dy);
                } else {
                    handleFreeResize(dx, dy);
                }
            }
            render();
        });

        // Get snap units for each tile mode - how much to move per tile add/remove
        function getTileSnapUnits(n, m, w, h) {
            const g = TILE_GEOMETRY[tileMode];
            const cellW = w / g.wF(n), cellH = h / g.hF(m);
            return { dx: cellW * g.snapW, dy: cellH * g.snapH };
        }

        // Calculate new rect dimensions when adding/removing tiles
        function calcExpandedRect(newN, newM, anchorX, anchorY) {
            const g = TILE_GEOMETRY[tileMode];
            const cellW = rectStart.width / g.wF(nStart), cellH = rectStart.height / g.hF(mStart);
            const newW = cellW * g.wF(newN), newH = cellH * g.hF(newM);
            return {
                x: anchorX ? rectStart.x + rectStart.width - newW : rectStart.x,
                y: anchorY ? rectStart.y + rectStart.height - newH : rectStart.y,
                width: newW, height: newH
            };
        }

        function handleExpandResize(dx, dy) {
            const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);

            // Direction multipliers: [dxSign, dySign, anchorX, anchorY]
            const cfg = {
                br: [1, 1, 0, 0], tl: [-1, -1, 1, 1], tr: [1, -1, 0, 1], bl: [-1, 1, 1, 0],
                right: [1, 0, 0, 0], left: [-1, 0, 1, 0], bottom: [0, 1, 0, 0], top: [0, -1, 0, 1]
            }[dragging];
            if (!cfg) return;

            const [dxs, dys, ax, ay] = cfg;

            // Only compute cell deltas for axes that this handle affects
            const cellDx = dxs ? Math.round(dx / snap.dx) : 0;
            const cellDy = dys ? Math.round(dy / snap.dy) : 0;

            const newN = Math.min(Math.max(1, nStart + dxs * cellDx), MAX_GRID);
            const newM = Math.min(Math.max(1, mStart + dys * cellDy), MAX_GRID);

            const newRect = calcExpandedRect(newN, newM, ax, ay);
            if (dxs) { rect.width = newRect.width; rect.x = newRect.x; nSlider.value = nInput.value = newN; }
            if (dys) { rect.height = newRect.height; rect.y = newRect.y; mSlider.value = mInput.value = newM; }
        }

        function handleAspectResize(dx, dy) {
            const sf = Math.max(Math.abs(dx) / rectStart.width, Math.abs(dy) / rectStart.height);

            if (['br', 'tl', 'tr', 'bl'].includes(dragging)) {
                const signs = { br: dx + dy, tl: -(dx + dy), tr: dx - dy, bl: -dx + dy };
                const sign = signs[dragging] > 0 ? 1 : -1;
                const newW = Math.max(MIN_RECT_SIZE, rectStart.width * (1 + sign * sf));
                const newH = newW / lockedAspectRatio;
                rect.width = newW; rect.height = newH;
                if (dragging[0] === 't') rect.y = rectStart.y + rectStart.height - newH;
                if (dragging[1] === 'l') rect.x = rectStart.x + rectStart.width - newW;
            } else {
                // Edge resize - scale from opposite edge center
                const isHoriz = dragging === 'left' || dragging === 'right';
                const delta = isHoriz ? dx : dy;
                const fromStart = dragging === 'left' || dragging === 'top';

                if (isHoriz) {
                    const newW = Math.max(MIN_RECT_SIZE, rectStart.width + (fromStart ? -delta : delta));
                    const newH = newW / lockedAspectRatio;
                    const centerY = rectStart.y + rectStart.height / 2;
                    rect.width = newW; rect.height = newH; rect.y = centerY - newH / 2;
                    if (fromStart) rect.x = rectStart.x + rectStart.width - newW;
                } else {
                    // Vertical edge - anchor top for bottom, anchor bottom for top
                    const newH = Math.max(MIN_RECT_SIZE, rectStart.height + (fromStart ? -delta : delta));
                    const newW = newH * lockedAspectRatio;
                    const centerX = rectStart.x + rectStart.width / 2;
                    rect.width = newW; rect.height = newH; rect.x = centerX - newW / 2;
                    if (fromStart) rect.y = rectStart.y + rectStart.height - newH;
                    // else: rect.y stays at rectStart.y (anchor top edge)
                }
            }
        }

        function handleFreeResize(dx, dy) {
            // For corners (tl, tr, bl, br): check character position
            // For edges (left, right, top, bottom): exact match only
            const isLeft = dragging === 'left' || dragging === 'tl' || dragging === 'bl';
            const isRight = dragging === 'right' || dragging === 'tr' || dragging === 'br';
            const isTop = dragging === 'top' || dragging === 'tl' || dragging === 'tr';
            const isBottom = dragging === 'bottom' || dragging === 'bl' || dragging === 'br';

            if (isRight) rect.width = Math.max(MIN_RECT_SIZE, rectStart.width + dx);
            if (isBottom) rect.height = Math.max(MIN_RECT_SIZE, rectStart.height + dy);
            if (isLeft) { const nw = Math.max(MIN_RECT_SIZE, rectStart.width - dx); rect.x = rectStart.x + rectStart.width - nw; rect.width = nw; }
            if (isTop) { const nh = Math.max(MIN_RECT_SIZE, rectStart.height - dy); rect.y = rectStart.y + rectStart.height - nh; rect.height = nh; }
        }

        window.addEventListener('mouseup', () => { if (dragging) autoSave(); dragging = null; });
        window.addEventListener('resize', () => { if (image) { resizeView(); render(); } });

        // Trackpad pan/zoom: two-finger scroll = pan, pinch = zoom
        container.addEventListener('wheel', e => {
            if (!image) return;
            e.preventDefault();

            const cr = container.getBoundingClientRect();
            const mouseX = e.clientX - cr.left;
            const mouseY = e.clientY - cr.top;

            if (e.ctrlKey) {
                // Pinch-to-zoom (ctrlKey is set by macOS during pinch gestures)
                const zoomFactor = 1 - e.deltaY * 0.01;
                const newZoom = Math.min(Math.max(0.1, viewZoom * zoomFactor), 20);

                // Zoom towards mouse position (relative to container center)
                const displayW = image.width * canvasScale;
                const displayH = image.height * canvasScale;
                const centerX = (cr.width - displayW) / 2;
                const centerY = (cr.height - displayH) / 2;

                // Current position in view space
                const viewX = mouseX - centerX - viewOffset.x;
                const viewY = mouseY - centerY - viewOffset.y;

                // Scale the offset to zoom towards cursor
                const scale = newZoom / viewZoom;
                viewOffset.x += viewX - viewX * scale;
                viewOffset.y += viewY - viewY * scale;
                viewZoom = newZoom;
            } else {
                // Two-finger pan
                viewOffset.x -= e.deltaX;
                viewOffset.y -= e.deltaY;
            }
            updateView();
        }, { passive: false });

        // Double-click to reset view
        mainSvg.addEventListener('dblclick', e => {
            if (!image) return;
            viewZoom = 1;
            viewOffset = { x: 0, y: 0 };
            updateView();
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', e => {
            if ('123'.includes(e.key)) {
                pushUndo();
                const opacity = { '1': 0, '2': 50, '3': 100 }[e.key];
                setBtnGroupValue('opacityBtns', opacity);
                gridOpacity = opacity / 100;
                update();
            } else if (e.key.toLowerCase() === 's') { e.preventDefault(); $('saveBtn').click(); }
            else if (e.key.toLowerCase() === 'g') { e.preventDefault(); $('saveSvgBtn').click(); }
            else if (e.key.toLowerCase() === 'x') { $('expandMode').click(); }
            else if (e.key.toLowerCase() === 'h') {
                pushUndo();
                const modes = ['square', 'hex', 'hexV', 'tri'];
                tileMode = modes[(modes.indexOf(tileMode) + 1) % modes.length];
                setBtnGroupValue('tileBtns', tileMode);
                update();
            }
            else if (e.key.toLowerCase() === 'e') { $('eyedropperBtn').click(); }
            else if (e.key.toLowerCase() === 'c') { $('chromaToggle').click(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        loadFromLocalStorage();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Alignment Tool</title>
    <script src="https://code.iconify.design/3/3.1.0/iconify.min.js"></script>
    <style>
        :root {
            --bg-dark: #0b0d14;
            --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            --glass-bg: rgba(255, 255, 255, 0.025);
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-border-subtle: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.15);
            --glass-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.75), 0 0 9px rgba(0, 0, 0, 0.2), 0 3px 8px rgba(0, 0, 0, 0.15);
            --accent: #e94560;
            --accent-glow: rgba(233, 69, 96, 0.4);
            --text-primary: #e8eef5;
            --text-muted: #8892a0;
            --shadow-deep: 0 8px 32px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 20px rgba(233, 69, 96, 0.2);
            --toolbar-height: 52px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body.dragging { user-select: none; -webkit-user-select: none; cursor: grabbing !important; }
        body.dragging * { cursor: grabbing !important; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            background-image: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            padding: 12px 20px;
            background: rgba(11, 13, 20, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            gap: 24px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid var(--glass-border);
            box-shadow: var(--shadow-deep);
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        .control-group input[type="range"] {
            width: 180px;
            cursor: pointer;
            -webkit-appearance: none;
            background: transparent;
            height: 4px;
        }
        .control-group input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(90deg, var(--accent) 0%, rgba(233, 69, 96, 0.3) 100%);
            border-radius: 2px;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            margin-top: -5px;
            box-shadow: 0 0 8px var(--accent-glow);
            cursor: pointer;
        }
        .btn, .icon-btn {
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn {
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .btn:hover, .icon-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 0 12px var(--accent-glow);
        }
        .btn.accent {
            background: linear-gradient(135deg, var(--accent) 0%, #c73a54 100%);
            border-color: var(--accent);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 0 12px var(--accent-glow);
        }
        .btn.accent:hover {
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 0 20px var(--accent-glow);
        }
        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            color: var(--text-muted);
            font-size: 16px;
        }
        .icon-btn:hover {
            color: var(--text-primary);
        }
        .icon-btn:active {
            transform: scale(0.9);
        }
        .icon-btn.active {
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4), 0 0 8px var(--accent-glow);
        }
        .icon-btn.bounce {
            animation: bounce-pulse 0.3s ease;
        }
        @keyframes bounce-pulse {
            0% { transform: scale(1); }
            30% { transform: scale(0.92); }
            60% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        /* Chain link button */
        .chain-link-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-muted);
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            transition: all 0.2s ease;
        }
        .chain-link-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
        }
        .chain-link-btn.active {
            color: var(--accent);
            border-color: var(--accent);
        }
        .chain-link-btn.active .chain-linked { display: block; }
        .chain-link-btn.active .chain-broken { display: none !important; }
        .chain-link-btn:not(.active) .chain-linked { display: none; }
        .chain-link-btn:not(.active) .chain-broken { display: block !important; }
        /* Slider pair with chain button floating centered between rows */
        .slider-pair-with-chain {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto 0 auto; /* Middle row is 0-height for positioning */
            gap: 6px;
            position: relative;
        }
        .slider-pair-with-chain > .control-group:nth-child(1) { grid-row: 1; }
        .slider-pair-with-chain > .control-group:nth-child(2) { grid-row: 3; }
        .slider-pair-with-chain > .chain-link-btn {
            grid-row: 2;
            justify-self: center;
            transform: translateY(-50%);
            z-index: 1;
        }
        .btn-group {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.2);
            padding: 3px;
            border-radius: 8px;
            position: relative;
        }
        .btn-group-indicator {
            position: absolute;
            top: 3px;
            bottom: 3px;
            background: var(--accent);
            border-radius: 6px;
            transition: left 0.2s ease, width 0.2s ease;
            z-index: 0;
            box-shadow: 0 0 8px var(--accent-glow);
        }
        .btn-group .btn {
            border: none;
            background: transparent;
            backdrop-filter: none;
            position: relative;
            z-index: 1;
        }
        .btn-group .btn:hover {
            background: var(--glass-bg);
        }
        .btn-group .btn.active {
            background: transparent;
            box-shadow: none;
        }
        .slider-group { display: flex; align-items: center; gap: 8px; }
        .num-input {
            width: 50px;
            color: var(--accent);
            padding: 4px;
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
        }
        .num-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 8px var(--accent-glow);
        }
        .canvas-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, rgba(30, 30, 50, 0.5) 0%, transparent 70%);
        }
        #canvasWrapper {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }
        #mainSvg { display: block; overflow: visible; }
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(11, 13, 20, 0.85);
            backdrop-filter: blur(10px);
            border: 2px dashed var(--accent);
            margin: 20px;
            border-radius: 16px;
            pointer-events: none;
            opacity: 0;
        }
        .drop-zone.active, .drop-zone.show-initial { opacity: 1; }
        .drop-zone.show-initial { pointer-events: auto; }
        .drop-zone p {
            font-size: 20px;
            color: var(--accent);
            font-weight: 500;
            text-shadow: 0 0 20px var(--accent-glow);
        }
        .instructions {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            font-size: 11px;
            color: var(--text-muted);
            max-width: 300px;
            box-shadow: var(--shadow-deep);
        }
        #infoField {
            color: var(--accent);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'SF Mono', 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            width: 300px;
            cursor: pointer;
        }
        #infoField:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 8px var(--accent-glow);
        }
        .chroma-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 8px;
        }
        .color-swatch {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            border: 2px solid var(--glass-border);
            cursor: pointer;
            background: conic-gradient(#808080 25%, #fff 25% 50%, #808080 50% 75%, #fff 75%);
            background-size: 6px 6px;
        }
        .color-swatch:hover {
            border-color: var(--accent);
        }
        .color-swatch-inner {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }
        .color-picker-hidden {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }
        .chroma-slider {
            width: 70px;
        }
        /* Minimap */
        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            display: none;
            padding: 2px; /* Space for viewport border */
        }
        .minimap.visible { display: block; }
        .minimap canvas {
            display: block;
        }
        .minimap-viewport {
            position: absolute;
            border: 2px solid var(--accent);
            pointer-events: none;
            box-sizing: border-box;
        }
        /* Palette panel */
        .palette-panel {
            position: fixed;
            top: var(--toolbar-height, 60px);
            right: 0;
            width: 260px;
            max-height: calc(100vh - var(--toolbar-height, 60px) - 20px);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-left: 1px solid var(--glass-border);
            border-bottom: 1px solid var(--glass-border);
            border-radius: 0 0 0 16px;
            transform: translateX(100%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: -8px 0 32px rgba(0, 0, 0, 0.3);
        }
        .palette-panel.open { transform: translateX(0); }
        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
        }
        .palette-header span {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .palette-toggle, .palette-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid var(--glass-border);
        }
        .palette-toggle label {
            font-size: 12px;
            color: var(--text-muted);
        }
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            align-content: start;
            min-height: 80px;
        }
        .palette-swatch {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            position: relative;
        }
        .palette-swatch:hover {
            border-color: var(--accent);
            box-shadow: 0 0 8px var(--accent-glow);
        }
        .palette-swatch .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            color: white;
            display: none;
            cursor: pointer;
            box-shadow: 0 0 6px var(--accent-glow);
        }
        .palette-swatch:hover .remove-btn { display: block; }
        .palette-stats {
            padding: 10px 15px;
            font-size: 11px;
            color: var(--text-muted);
            border-top: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.1);
        }
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        /* Utility classes */
        .label-fixed { width: 40px; }
        .tolerance-val { min-width: 25px; font-size: 12px; color: var(--accent); }
    </style>
</head>
<body>
    <!-- SVG symbol definitions (reusable icons) -->
    <svg style="display:none">
        <symbol id="chain-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path class="chain-linked" d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
            <path class="chain-linked" d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            <path class="chain-broken" style="display:none" d="M9 17l-4 4M15 7l4-4M8 12H4M20 12h-4M12 8V4M12 20v-4"/>
        </symbol>
    </svg>
    <div class="controls">
        <div class="control-group slider-group">
            <div class="slider-pair-with-chain">
                <div class="control-group">
                    <label class="label-fixed">Cols:</label>
                    <input type="range" id="nSlider" min="1" max="500" value="16">
                    <input type="number" id="nInput" min="1" max="500" value="16" class="num-input">
                </div>
                <div class="control-group">
                    <label class="label-fixed">Rows:</label>
                    <input type="range" id="mSlider" min="1" max="500" value="16">
                    <input type="number" id="mInput" min="1" max="500" value="16" class="num-input">
                </div>
                <button class="chain-link-btn active" id="resolutionLock" title="Link rows and columns">
                    <svg width="20" height="20"><use href="#chain-icon"/></svg>
                </button>
            </div>
        </div>
        <div class="control-group">
            <label>Aspect:</label>
            <button class="chain-link-btn active" id="aspectLock" title="Lock rectangle aspect ratio">
                <svg width="20" height="20"><use href="#chain-icon"/></svg>
            </button>
        </div>
        <div class="control-group">
            <label>Grid Opacity:</label>
            <div class="btn-group" id="opacityBtns">
                <button class="btn" data-value="0">0%</button>
                <button class="btn" data-value="50">50%</button>
                <button class="btn active" data-value="100">100%</button>
                <button class="btn" data-value="tiles" title="Tiles only (no grid lines)">Tiles</button>
                <button class="btn" data-value="solo" title="Tiles only (no image)">Solo</button>
            </div>
        </div>
        <div class="control-group">
            <label>Sample:</label>
            <div class="btn-group" id="sampleBtns">
                <button class="btn active" data-value="center">Center</button>
                <button class="btn" data-value="mean">Mean</button>
                <button class="btn" data-value="median">Median</button>
            </div>
        </div>
        <div class="control-group">
            <label>Expand:</label>
            <button class="icon-btn" id="expandMode" title="Expand mode: resize by adding/removing cells">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="currentColor">
                    <rect x="1" y="1" width="5" height="5" rx="1"/>
                    <rect x="7" y="1" width="5" height="5" rx="1"/>
                    <rect x="1" y="7" width="5" height="5" rx="1"/>
                    <rect x="7" y="7" width="5" height="5" rx="1" opacity="0.4"/>
                    <rect x="13" y="7" width="4" height="5" rx="1" opacity="0.4"/>
                    <rect x="7" y="13" width="5" height="4" rx="1" opacity="0.4"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Tiles:</label>
            <div class="btn-group" id="tileBtns">
                <button class="btn active" data-value="square" title="Square tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><rect x="1" y="1" width="12" height="12"/></svg>
                </button>
                <button class="btn" data-value="hex" title="Flat-top hexagon (H)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M4 1H10L13 7L10 13H4L1 7L4 1Z"/></svg>
                </button>
                <button class="btn" data-value="hexV" title="Pointy-top hexagon">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 0.5L13 4V10L7 13.5L1 10V4L7 0.5Z"/></svg>
                </button>
                <button class="btn" data-value="tri" title="Equilateral triangles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 1L13 13H1L7 1Z"/></svg>
                </button>
                <button class="btn" data-value="triH" title="Horizontal triangles (rotated 90°)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M1 7L13 1V13L1 7Z"/></svg>
                </button>
                <button class="btn" data-value="custom" id="customSvgBtn" title="Load custom SVG shape">
                    <span class="iconify" data-icon="mdi:shape-plus" data-width="14"></span>
                </button>
            </div>
            <input type="file" id="customSvgInput" accept=".svg" style="display:none">
        </div>
        <div class="control-group">
            <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <span class="iconify" data-icon="mdi:undo" data-width="20"></span>
            </button>
            <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <span class="iconify" data-icon="mdi:redo" data-width="20"></span>
            </button>
        </div>
        <div class="control-group">
            <button class="btn" id="resetBtn">Reset Grid</button>
        </div>
        <div class="control-group">
            <button class="btn accent" id="saveBtn">Save PNG</button>
            <button class="btn accent" id="saveSvgBtn">Save SVG</button>
        </div>
        <div class="control-group">
            <input type="text" id="infoField" readonly title="Click to copy">
        </div>
        <div class="control-group">
            <label>Grid:</label>
            <div class="color-swatch" id="gridColorSwatch" title="Grid/border color">
                <div class="color-swatch-inner" id="gridColorSwatchInner" style="background:#e94560"></div>
            </div>
            <input type="color" id="gridColorPicker" class="color-picker-hidden" value="#e94560">
        </div>
        <div class="control-group chroma-group">
            <label>Chroma:</label>
            <button class="icon-btn" id="chromaToggle" title="Enable chroma key">
                <span class="iconify" data-icon="mdi:eye-off" data-width="18"></span>
            </button>
            <div class="color-swatch" id="chromaSwatch" title="Click to pick color">
                <div class="color-swatch-inner" id="chromaSwatchInner"></div>
            </div>
            <input type="color" id="chromaColorPicker" class="color-picker-hidden" value="#00ff00">
            <button class="icon-btn" id="eyedropperBtn" title="Pick color from image (E)">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <input type="range" id="chromaTolerance" min="0" max="150" value="30" class="chroma-slider" title="Color tolerance">
            <span id="chromaToleranceVal" class="tolerance-val">30</span>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="paletteToggle" title="Color Palette (P)">
                <span class="iconify" data-icon="mdi:palette" data-width="20"></span>
            </button>
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <div id="canvasWrapper">
            <svg id="mainSvg"></svg>
        </div>
        <div class="drop-zone show-initial" id="dropZone">
            <p>Drop an image here</p>
        </div>
        <div class="minimap" id="minimap">
            <canvas id="minimapCanvas"></canvas>
            <div class="minimap-viewport" id="minimapViewport"></div>
        </div>
    </div>

    <div class="instructions">
        Drag corners to resize the pixel grid. Drag inside to move it. Use sliders to change grid dimensions.
    </div>

    <!-- Palette Panel -->
    <div class="palette-panel" id="palettePanel">
        <div class="palette-header">
            <span>Color Palette</span>
            <button class="icon-btn" id="palettePanelClose" style="padding: 4px 8px;">×</button>
        </div>
        <div class="palette-toggle">
            <button class="icon-btn" id="paletteEnabledBtn" title="Enable palette restriction">
                <span class="iconify" data-icon="mdi:checkbox-blank-outline" data-width="18"></span>
            </button>
            <label>Restrict to palette</label>
        </div>
        <div class="palette-controls">
            <button class="btn" id="addColorPickerBtn" title="Add color via picker">+ Color</button>
            <button class="icon-btn" id="paletteEyedropperBtn" title="Pick color from image">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <button class="btn" id="clearColorsBtn">Clear</button>
        </div>
        <div class="palette-grid" id="paletteGrid"></div>
        <div class="palette-stats"><span id="paletteColorCount">0</span> colors</div>
    </div>
    <input type="color" id="paletteColorPicker" class="color-picker-hidden">

    <script>
        const $ = id => document.getElementById(id);
        const mainSvg = $('mainSvg');
        const container = $('canvasContainer');
        const wrapper = $('canvasWrapper');
        const dropZone = $('dropZone');
        const nSlider = $('nSlider'), mSlider = $('mSlider');
        const nInput = $('nInput'), mInput = $('mInput');

        // Global constants
        const MAX_GRID = 500;
        const MAX_UNDO = 50;
        const DEFAULT_N = 16, DEFAULT_M = 16;
        const DEFAULT_RECT_SIZE = 200;
        const MIN_RECT_SIZE = 20;
        const RETINA = window.devicePixelRatio || 1;
        const HANDLE_SCREEN_PX = 12;
        const MINIMAP_SIZE = 150;
        const CIRCLE_SEGMENTS = 32;
        const CONTAINER_PADDING = 40;

        let image = null;
        let viewMode = '100'; // '0', '50', '100', 'tiles', 'solo'
        const VIEW_MODES = {
            '0':     { fillOpacity: 0,   showStroke: true,  showImage: true },
            '50':    { fillOpacity: 0.5, showStroke: true,  showImage: true },
            '100':   { fillOpacity: 1,   showStroke: true,  showImage: true },
            'tiles': { fillOpacity: 1,   showStroke: false, showImage: true },
            'solo':  { fillOpacity: 1,   showStroke: false, showImage: false }
        };
        let sampleMode = 'center';
        let rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE, flipX: false, flipY: false };
        let dragging = null;
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, width: 0, height: 0 };
        let nStart = DEFAULT_N, mStart = DEFAULT_M;

        let undoStack = [], redoStack = [];

        let aspectLocked = true, lockedAspectRatio = 1;
        let resolutionLocked = true, expandModeOn = false;

        // Chroma key state
        let chromaEnabled = false;
        let chromaColor = [0, 255, 0]; // RGB
        let chromaTolerance = 30;
        let eyedropperMode = false;
        let tileMode = 'square'; // 'square', 'hex', 'hexV', 'tri', 'triH'
        let gridColor = [233, 69, 96]; // RGB for #e94560

        // Palette state
        let paletteEnabled = false;
        let paletteColors = []; // Array of [r,g,b]
        let palettePanelOpen = false;
        let paletteEyedropperMode = false;
        let paletteEditingIndex = -1; // -1 = adding new, >= 0 = editing existing

        // View transform state (pan/zoom for the whole canvas view)
        let viewOffset = { x: 0, y: 0 };
        let viewZoom = 1;

        // === HELPER FUNCTIONS ===
        function update() { render(); autoSave(); }

        function setBtnGroupValue(groupId, value) {
            const group = $(groupId);
            group.querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value == value));
            updateIndicator(group);
        }

        function setChromaEnabled(enabled) {
            chromaEnabled = enabled;
            $('chromaToggle').classList.toggle('active', enabled);
            $('chromaToggle').querySelector('.iconify').dataset.icon = enabled ? 'mdi:eye' : 'mdi:eye-off';
            updateChromaSwatch();
        }

        function setEyedropperMode(enabled) {
            eyedropperMode = enabled;
            $('eyedropperBtn').classList.toggle('active', enabled);
            mainSvg.style.cursor = enabled ? 'crosshair' : 'default';
        }

        function setLockState(btnId, locked) {
            const btn = $(btnId);
            btn.classList.toggle('active', locked);
            // Chain buttons use CSS to show/hide linked vs broken state
        }

        function aggregatePixels(pixels) {
            if (!pixels.length) return null;
            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            return medianColor(pixels);
        }

        function colorToFill(color, nullValue = null) {
            if (!color) return nullValue;
            if (chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance) {
                return nullValue;
            }
            // Apply palette restriction
            if (paletteEnabled && paletteColors.length) {
                color = nearestPaletteColor(color);
            }
            return `rgb(${color[0]|0},${color[1]|0},${color[2]|0})`;
        }

        function nearestPaletteColor([r, g, b]) {
            let minDist = Infinity, nearest = [r, g, b];
            for (const pc of paletteColors) {
                const d = colorDistance(r, g, b, pc[0], pc[1], pc[2]);
                if (d < minDist) { minDist = d; nearest = pc; }
            }
            return nearest;
        }

        // Iterate over all tiles with shape-aware geometry
        // callback(col, row, contourIdx, geom) is called for each tile
        function forEachTile(n, m, callback) {
            const shape = SHAPES[tileMode];
            const geom = shape.getGeometry(n, m, rect.width, rect.height);
            const numContours = tileMode === 'custom' ? Math.max(1, SHAPES.custom.contours.length) : 1;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                for (let ci = 0; ci < numContours; ci++) callback(col, row, ci, geom);
            }
        }

        // Point-in-shape test functions (shared utilities)
        function pointInHex(px, py, cx, cy, halfW, halfH) {
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            return halfH * halfW - halfH * dx - halfW * 0.5 * dy >= 0;
        }
        function pointInHexV(px, py, cx, cy, halfW, halfH) {
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            return halfW * halfH - halfW * dy - halfH * 0.5 * dx >= 0;
        }
        function pointInTriangle(px, py, x0, y0, x1, y1, x2, y2) {
            const area = 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2);
            const s = 1 / (2 * area) * (y0 * x2 - x0 * y2 + (y2 - y0) * px + (x0 - x2) * py);
            const t = 1 / (2 * area) * (x0 * y1 - y0 * x1 + (y0 - y1) * px + (x1 - x0) * py);
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }

        // Shared sampling helper - extracts color from image data for a tile
        // getBounds: tile -> {x0, y0, x1, y1} bounding box
        // pointInShape: (px, py, tile) -> bool, or null for rectangular tiles
        function sampleShape(imgData, tile, w, h, getBounds, pointInShape) {
            if (sampleMode === 'center') {
                const idx = (Math.floor(tile.cy) * w + Math.floor(tile.cx)) * 4;
                return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
            }
            const { x0, y0, x1, y1 } = getBounds(tile);
            const bx0 = Math.max(0, Math.floor(x0)), by0 = Math.max(0, Math.floor(y0));
            const bx1 = Math.min(w, Math.ceil(x1)), by1 = Math.min(h, Math.ceil(y1));
            const pixels = [];
            for (let y = by0; y < by1; y++) for (let x = bx0; x < bx1; x++) {
                if (!pointInShape || pointInShape(x + 0.5, y + 0.5, tile)) {
                    const idx = (y * w + x) * 4;
                    pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                }
            }
            return aggregatePixels(pixels);
        }

        // Unified shape definitions - each shape defines its geometry, tile generation, and sampling
        const SHAPES = {
            square: {
                type: 'rect',
                wF: n => n, hF: m => m, snapW: 1, snapH: 1,
                getGeometry: (n, m, w, h) => ({ cellW: w / n, cellH: h / m }),
                getTile: (col, row, g, ox, oy) => {
                    const x = ox + col * g.cellW, y = oy + row * g.cellH;
                    return { x, y, width: g.cellW, height: g.cellH, cx: x + g.cellW / 2, cy: y + g.cellH / 2 };
                },
                sample: (imgData, t, w, h) => sampleShape(imgData, t, w, h, t => ({ x0: t.x, y0: t.y, x1: t.x + t.width, y1: t.y + t.height }), null),
                setAttrs: (el, t) => { el.setAttribute('x', t.x); el.setAttribute('y', t.y); el.setAttribute('width', t.width); el.setAttribute('height', t.height); },
                svgTag: (t, sx, sy) => `<rect x="${(t.x * sx).toFixed(2)}" y="${(t.y * sy).toFixed(2)}" width="${(t.width * sx).toFixed(2)}" height="${(t.height * sy).toFixed(2)}"`
            },
            hex: {
                type: 'polygon',
                wF: n => n * 0.75 + 0.25, hF: m => m + 0.5, snapW: 0.75, snapH: 1,
                getGeometry: (n, m, w, h) => {
                    const hexW = w / (n * 0.75 + 0.25), hexH = h / (m + 0.5);
                    return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
                },
                getTile: (col, row, g, ox, oy) => {
                    const cx = ox + col * g.hexW * 0.75 + g.halfW;
                    const cy = oy + row * g.hexH + (col % 2 === 1 ? g.halfH : 0) + g.halfH;
                    return { cx, cy, halfW: g.halfW, halfH: g.halfH,
                        points: `${cx + g.halfW},${cy} ${cx + g.halfW * 0.5},${cy - g.halfH} ${cx - g.halfW * 0.5},${cy - g.halfH} ${cx - g.halfW},${cy} ${cx - g.halfW * 0.5},${cy + g.halfH} ${cx + g.halfW * 0.5},${cy + g.halfH}` };
                },
                sample: (imgData, t, w, h) => sampleShape(imgData, t, w, h,
                    t => ({ x0: t.cx - t.halfW, y0: t.cy - t.halfH, x1: t.cx + t.halfW, y1: t.cy + t.halfH }),
                    (px, py, t) => pointInHex(px, py, t.cx, t.cy, t.halfW, t.halfH)),
                setAttrs: (el, t) => el.setAttribute('points', t.points),
                svgTag: (t, sx, sy, ox, oy) => {
                    const cx = t.cx - ox, cy = t.cy - oy;
                    const pts = [[cx + t.halfW, cy], [cx + t.halfW * 0.5, cy - t.halfH], [cx - t.halfW * 0.5, cy - t.halfH], [cx - t.halfW, cy], [cx - t.halfW * 0.5, cy + t.halfH], [cx + t.halfW * 0.5, cy + t.halfH]];
                    return `<polygon points="${pts.map(([x, y]) => `${(x * sx).toFixed(2)},${(y * sy).toFixed(2)}`).join(' ')}"`;
                }
            },
            hexV: {
                type: 'polygon',
                wF: n => n + 0.5, hF: m => m * 0.75 + 0.25, snapW: 1, snapH: 0.75,
                getGeometry: (n, m, w, h) => {
                    const hexW = w / (n + 0.5), hexH = h / (m * 0.75 + 0.25);
                    return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
                },
                getTile: (col, row, g, ox, oy) => {
                    const cx = ox + col * g.hexW + (row % 2 === 1 ? g.halfW : 0) + g.halfW;
                    const cy = oy + row * g.hexH * 0.75 + g.halfH;
                    return { cx, cy, halfW: g.halfW, halfH: g.halfH,
                        points: `${cx},${cy - g.halfH} ${cx + g.halfW},${cy - g.halfH * 0.5} ${cx + g.halfW},${cy + g.halfH * 0.5} ${cx},${cy + g.halfH} ${cx - g.halfW},${cy + g.halfH * 0.5} ${cx - g.halfW},${cy - g.halfH * 0.5}` };
                },
                sample: (imgData, t, w, h) => sampleShape(imgData, t, w, h,
                    t => ({ x0: t.cx - t.halfW, y0: t.cy - t.halfH, x1: t.cx + t.halfW, y1: t.cy + t.halfH }),
                    (px, py, t) => pointInHexV(px, py, t.cx, t.cy, t.halfW, t.halfH)),
                setAttrs: (el, t) => el.setAttribute('points', t.points),
                svgTag: (t, sx, sy, ox, oy) => {
                    const cx = t.cx - ox, cy = t.cy - oy;
                    const pts = [[cx, cy - t.halfH], [cx + t.halfW, cy - t.halfH * 0.5], [cx + t.halfW, cy + t.halfH * 0.5], [cx, cy + t.halfH], [cx - t.halfW, cy + t.halfH * 0.5], [cx - t.halfW, cy - t.halfH * 0.5]];
                    return `<polygon points="${pts.map(([x, y]) => `${(x * sx).toFixed(2)},${(y * sy).toFixed(2)}`).join(' ')}"`;
                }
            },
            tri: {
                type: 'polygon',
                wF: n => (n + 1) / 2, hF: m => m, snapW: 0.5, snapH: 1,
                getGeometry: (n, m, w, h) => ({ triW: w / ((n + 1) / 2), triH: h / m }),
                getTile: (col, row, g, ox, oy) => {
                    const isUp = (col + row) % 2 === 0;
                    const baseX = ox + col * g.triW / 2, baseY = oy + row * g.triH;
                    if (isUp) return { x0: baseX + g.triW / 2, y0: baseY, x1: baseX, y1: baseY + g.triH, x2: baseX + g.triW, y2: baseY + g.triH, cx: baseX + g.triW / 2, cy: baseY + g.triH * 2 / 3 };
                    return { x0: baseX, y0: baseY, x1: baseX + g.triW, y1: baseY, x2: baseX + g.triW / 2, y2: baseY + g.triH, cx: baseX + g.triW / 2, cy: baseY + g.triH / 3 };
                },
                sample: (imgData, t, w, h) => sampleShape(imgData, t, w, h,
                    t => ({ x0: Math.min(t.x0, t.x1, t.x2), y0: Math.min(t.y0, t.y1, t.y2), x1: Math.max(t.x0, t.x1, t.x2), y1: Math.max(t.y0, t.y1, t.y2) }),
                    (px, py, t) => pointInTriangle(px, py, t.x0, t.y0, t.x1, t.y1, t.x2, t.y2)),
                setAttrs: (el, t) => el.setAttribute('points', `${t.x0},${t.y0} ${t.x1},${t.y1} ${t.x2},${t.y2}`),
                svgTag: (t, sx, sy, ox, oy) => `<polygon points="${[(t.x0-ox)*sx,(t.y0-oy)*sy,(t.x1-ox)*sx,(t.y1-oy)*sy,(t.x2-ox)*sx,(t.y2-oy)*sy].map(v=>v.toFixed(2)).join(',')}"`
            },
            triH: {
                type: 'polygon',
                wF: n => n, hF: m => (m + 1) / 2, snapW: 1, snapH: 0.5,
                getGeometry: (n, m, w, h) => ({ triW: w / n, triH: h / ((m + 1) / 2) }),
                getTile: (col, row, g, ox, oy) => {
                    const isRight = (col + row) % 2 === 0;
                    const baseX = ox + col * g.triW, baseY = oy + row * g.triH / 2;
                    if (isRight) return { x0: baseX, y0: baseY, x1: baseX, y1: baseY + g.triH, x2: baseX + g.triW, y2: baseY + g.triH / 2, cx: baseX + g.triW * 2 / 3, cy: baseY + g.triH / 2 };
                    return { x0: baseX + g.triW, y0: baseY, x1: baseX + g.triW, y1: baseY + g.triH, x2: baseX, y2: baseY + g.triH / 2, cx: baseX + g.triW / 3, cy: baseY + g.triH / 2 };
                },
                sample: (imgData, t, w, h) => sampleShape(imgData, t, w, h,
                    t => ({ x0: Math.min(t.x0, t.x1, t.x2), y0: Math.min(t.y0, t.y1, t.y2), x1: Math.max(t.x0, t.x1, t.x2), y1: Math.max(t.y0, t.y1, t.y2) }),
                    (px, py, t) => pointInTriangle(px, py, t.x0, t.y0, t.x1, t.y1, t.x2, t.y2)),
                setAttrs: (el, t) => el.setAttribute('points', `${t.x0},${t.y0} ${t.x1},${t.y1} ${t.x2},${t.y2}`),
                svgTag: (t, sx, sy, ox, oy) => `<polygon points="${[(t.x0-ox)*sx,(t.y0-oy)*sy,(t.x1-ox)*sx,(t.y1-oy)*sy,(t.x2-ox)*sx,(t.y2-oy)*sy].map(v=>v.toFixed(2)).join(',')}"`
            },
            custom: {
                type: 'polygon',
                contours: [], // normalized contours [[{x,y}, ...], ...]
                wF: n => n, hF: m => m, snapW: 1, snapH: 1,
                // For custom, we need n*m*contours.length elements
                getTileCount: function(n, m) { return n * m * Math.max(1, this.contours.length); },
                getGeometry: (n, m, w, h) => ({ cellW: w / n, cellH: h / m }),
                getTile: function(col, row, g, ox, oy, contourIdx) {
                    // contourIdx tells us which contour within this cell
                    const x = ox + col * g.cellW, y = oy + row * g.cellH;
                    const contour = this.contours[contourIdx] || this.contours[0] || [];
                    const pts = contour.map(p => [x + p.x * g.cellW, y + p.y * g.cellH]);
                    // Calculate centroid for sampling
                    let cx = 0, cy = 0;
                    for (const [px, py] of pts) { cx += px; cy += py; }
                    cx /= pts.length || 1;
                    cy /= pts.length || 1;
                    // Bounding box for this specific polygon
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (const [px, py] of pts) {
                        if (px < minX) minX = px;
                        if (py < minY) minY = py;
                        if (px > maxX) maxX = px;
                        if (py > maxY) maxY = py;
                    }
                    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY, cx, cy, pts,
                        points: pts.map(p => p.join(',')).join(' ') };
                },
                sample: function(imgData, t, w, h) {
                    return sampleShape(imgData, t, w, h,
                        t => ({ x0: t.x, y0: t.y, x1: t.x + t.w, y1: t.y + t.h }),
                        (px, py, t) => pointInPolygon(px, py, t.pts));
                },
                setAttrs: (el, t) => el.setAttribute('points', t.points),
                svgTag: (t, sx, sy, ox, oy) => {
                    const pts = t.pts.map(([px, py]) => `${((px - ox) * sx).toFixed(2)},${((py - oy) * sy).toFixed(2)}`).join(' ');
                    return `<polygon points="${pts}"`;
                }
            }
        };

        // Point-in-polygon test (ray casting algorithm)
        function pointInPolygon(px, py, pts) {
            let inside = false;
            for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
                const xi = pts[i][0], yi = pts[i][1];
                const xj = pts[j][0], yj = pts[j][1];
                if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Multiply two 2D transform matrices [a,b,c,d,e,f]
        function multiplyMatrix(a, b) {
            return [
                a[0]*b[0] + a[2]*b[1], a[1]*b[0] + a[3]*b[1],
                a[0]*b[2] + a[2]*b[3], a[1]*b[2] + a[3]*b[3],
                a[0]*b[4] + a[2]*b[5] + a[4], a[1]*b[4] + a[3]*b[5] + a[5]
            ];
        }

        // Apply transform matrix to a point
        function applyTransform(m, x, y) {
            return { x: m[0]*x + m[2]*y + m[4], y: m[1]*x + m[3]*y + m[5] };
        }

        // Parse SVG transform attribute into a 2D matrix [a,b,c,d,e,f]
        function parseTransform(transformStr) {
            if (!transformStr) return [1, 0, 0, 1, 0, 0]; // identity
            let m = [1, 0, 0, 1, 0, 0];
            const ops = transformStr.match(/\w+\([^)]+\)/g) || [];
            for (const op of ops) {
                const match = op.match(/(\w+)\(([^)]+)\)/);
                if (!match) continue;
                const [, fn, args] = match;
                const nums = args.split(/[\s,]+/).map(Number);
                let t;
                switch (fn) {
                    case 'matrix': t = nums; break;
                    case 'translate': t = [1, 0, 0, 1, nums[0] || 0, nums[1] || 0]; break;
                    case 'scale':
                        const sx = nums[0] || 1, sy = nums[1] !== undefined ? nums[1] : sx;
                        t = [sx, 0, 0, sy, 0, 0]; break;
                    case 'rotate':
                        const a = nums[0] * Math.PI / 180, cos = Math.cos(a), sin = Math.sin(a);
                        const cx = nums[1] || 0, cy = nums[2] || 0;
                        if (cx || cy) {
                            t = [cos, sin, -sin, cos, cx - cos*cx + sin*cy, cy - sin*cx - cos*cy];
                        } else {
                            t = [cos, sin, -sin, cos, 0, 0];
                        }
                        break;
                    case 'skewX':
                        t = [1, 0, Math.tan(nums[0] * Math.PI / 180), 1, 0, 0]; break;
                    case 'skewY':
                        t = [1, Math.tan(nums[0] * Math.PI / 180), 0, 1, 0, 0]; break;
                    default: continue;
                }
                m = multiplyMatrix(m, t);
            }
            return m;
        }

        // Get cumulative transform from element up to root
        function getCumulativeTransform(el, stopAt) {
            let m = [1, 0, 0, 1, 0, 0];
            const stack = [];
            while (el && el !== stopAt && el.nodeType === 1) {
                const t = el.getAttribute('transform');
                if (t) stack.push(parseTransform(t));
                el = el.parentNode;
            }
            // Apply transforms from root down (reverse order)
            for (let i = stack.length - 1; i >= 0; i--) {
                m = multiplyMatrix(m, stack[i]);
            }
            return m;
        }

        // Extract points from a shape element
        function extractShapePoints(shape) {
            const tagName = shape.tagName.toLowerCase();
            let points = [];

            if (tagName === 'polygon' || tagName === 'polyline') {
                const ptsAttr = shape.getAttribute('points');
                if (ptsAttr) {
                    const coords = ptsAttr.trim().split(/[\s,]+/).map(Number);
                    for (let i = 0; i < coords.length - 1; i += 2) {
                        points.push({ x: coords[i], y: coords[i + 1] });
                    }
                }
            } else if (tagName === 'rect') {
                const rx = parseFloat(shape.getAttribute('x')) || 0;
                const ry = parseFloat(shape.getAttribute('y')) || 0;
                const rw = parseFloat(shape.getAttribute('width')) || 0;
                const rh = parseFloat(shape.getAttribute('height')) || 0;
                points = [{ x: rx, y: ry }, { x: rx + rw, y: ry }, { x: rx + rw, y: ry + rh }, { x: rx, y: ry + rh }];
            } else if (tagName === 'circle') {
                const ccx = parseFloat(shape.getAttribute('cx')) || 0;
                const ccy = parseFloat(shape.getAttribute('cy')) || 0;
                const r = parseFloat(shape.getAttribute('r')) || 0;
                for (let i = 0; i < CIRCLE_SEGMENTS; i++) {
                    const angle = (i / CIRCLE_SEGMENTS) * Math.PI * 2;
                    points.push({ x: ccx + r * Math.cos(angle), y: ccy + r * Math.sin(angle) });
                }
            } else if (tagName === 'ellipse') {
                const ecx = parseFloat(shape.getAttribute('cx')) || 0;
                const ecy = parseFloat(shape.getAttribute('cy')) || 0;
                const erx = parseFloat(shape.getAttribute('rx')) || 0;
                const ery = parseFloat(shape.getAttribute('ry')) || 0;
                for (let i = 0; i < CIRCLE_SEGMENTS; i++) {
                    const angle = (i / CIRCLE_SEGMENTS) * Math.PI * 2;
                    points.push({ x: ecx + erx * Math.cos(angle), y: ecy + ery * Math.sin(angle) });
                }
            } else if (tagName === 'path') {
                const d = shape.getAttribute('d');
                if (d) points = linearizePath(d);
            }
            return points;
        }

        // Check if element has a fill (not none/transparent)
        function hasFill(el) {
            // Check style attribute first
            const style = el.getAttribute('style') || '';
            const styleMatch = style.match(/fill\s*:\s*([^;]+)/);
            if (styleMatch) {
                const val = styleMatch[1].trim();
                if (val === 'none' || val === 'transparent') return false;
                if (val) return true;
            }
            const fill = el.getAttribute('fill');
            if (fill === 'none' || fill === 'transparent') return false;
            // Default fill is black if not specified
            return true;
        }

        // Parse SVG file and extract filled polygon contours
        function parseSvgForContours(svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const errorNode = doc.querySelector('parsererror');
            if (errorNode) throw new Error('Invalid SVG: ' + errorNode.textContent);

            const svg = doc.querySelector('svg');
            if (!svg) throw new Error('No SVG element found');

            // Get viewBox or width/height for normalization
            let vbX = 0, vbY = 0, vbW, vbH;
            const viewBox = svg.getAttribute('viewBox');
            if (viewBox) {
                const parts = viewBox.split(/[\s,]+/).map(Number);
                [vbX, vbY, vbW, vbH] = parts;
            } else {
                vbW = parseFloat(svg.getAttribute('width')) || 100;
                vbH = parseFloat(svg.getAttribute('height')) || 100;
            }
            if (!vbW || !vbH) throw new Error('Cannot determine SVG dimensions');

            const contours = [];

            // Helper to process a shape and add to contours
            // extraTransform: transform to apply AFTER the shape's own transform (for <use> context)
            // stopAtForShape: where to stop collecting shape's transforms (null = go to svg, or stop at referenced element's parent)
            function processShape(shape, extraTransform, localTransformOnly) {
                if (!hasFill(shape)) return;
                let points = extractShapePoints(shape);
                if (points.length < 3) return;

                // Get shape's own transform (just its own attribute, not parent chain)
                // When used via <use>, we only want the shape's local transform
                const shapeTransform = localTransformOnly
                    ? parseTransform(shape.getAttribute('transform'))
                    : getCumulativeTransform(shape, svg);

                // Combine: extraTransform is the context (use's chain), shape's transform is local
                // Order: first apply shape's local transform, then the context transform
                const finalTransform = extraTransform
                    ? multiplyMatrix(extraTransform, shapeTransform)
                    : shapeTransform;

                // Apply transform to all points
                points = points.map(p => applyTransform(finalTransform, p.x, p.y));

                // Normalize to 0-1 range
                const normalized = points.map(p => ({
                    x: (p.x - vbX) / vbW,
                    y: (p.y - vbY) / vbH
                }));
                contours.push(normalized);
            }

            // Process direct shapes (polygon, path, rect, circle, ellipse, polyline)
            const shapes = svg.querySelectorAll('polygon, path, rect, circle, ellipse, polyline');
            for (const shape of shapes) {
                // Skip shapes inside defs (they're templates, not rendered directly)
                if (shape.closest('defs')) continue;
                processShape(shape, null, false);
            }

            // Process <use> elements - these reference other shapes
            const uses = svg.querySelectorAll('use');
            for (const use of uses) {
                const href = use.getAttribute('href') || use.getAttribute('xlink:href');
                if (!href || !href.startsWith('#')) continue;

                const refId = href.slice(1);
                const referenced = doc.getElementById(refId);
                if (!referenced) continue;

                // Get transform from <use> element up to svg (this is the "context" transform)
                const useTransform = getCumulativeTransform(use, svg);

                // Add x/y offset from <use> as additional translation
                const ux = parseFloat(use.getAttribute('x')) || 0;
                const uy = parseFloat(use.getAttribute('y')) || 0;
                const offsetTransform = [1, 0, 0, 1, ux, uy];
                const combinedUseTransform = multiplyMatrix(useTransform, offsetTransform);

                // Referenced element might be a shape or a group
                const tagName = referenced.tagName.toLowerCase();
                if (['polygon', 'path', 'rect', 'circle', 'ellipse', 'polyline'].includes(tagName)) {
                    // Use localTransformOnly=true since the context already includes parent transforms
                    processShape(referenced, combinedUseTransform, true);
                } else if (tagName === 'g') {
                    // For a group, we need to apply the group's own transform too
                    const groupTransform = parseTransform(referenced.getAttribute('transform'));
                    const fullContextTransform = multiplyMatrix(combinedUseTransform, groupTransform);
                    // Process all shapes in the group with their local transforms only
                    const groupShapes = referenced.querySelectorAll('polygon, path, rect, circle, ellipse, polyline');
                    for (const gs of groupShapes) {
                        processShape(gs, fullContextTransform, true);
                    }
                }
            }

            if (contours.length === 0) throw new Error('No filled shapes found in SVG');
            return contours;
        }

        // Linearize SVG path - extract points, treating curves as straight lines
        function linearizePath(d) {
            const points = [];
            let cx = 0, cy = 0; // current position
            let sx = 0, sy = 0; // start of subpath

            // Tokenize: split into commands and numbers
            const tokens = d.match(/[MmLlHhVvCcSsQqTtAaZz]|[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g) || [];
            let i = 0;

            function num() { return parseFloat(tokens[i++]) || 0; }

            while (i < tokens.length) {
                const cmd = tokens[i++];
                switch (cmd) {
                    case 'M': cx = num(); cy = num(); sx = cx; sy = cy; points.push({ x: cx, y: cy }); break;
                    case 'm': cx += num(); cy += num(); sx = cx; sy = cy; points.push({ x: cx, y: cy }); break;
                    case 'L': cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 'l': cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'H': cx = num(); points.push({ x: cx, y: cy }); break;
                    case 'h': cx += num(); points.push({ x: cx, y: cy }); break;
                    case 'V': cy = num(); points.push({ x: cx, y: cy }); break;
                    case 'v': cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'C': num(); num(); num(); num(); cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 'c': num(); num(); num(); num(); cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'S': num(); num(); cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 's': num(); num(); cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'Q': num(); num(); cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 'q': num(); num(); cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'T': cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 't': cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'A': num(); num(); num(); num(); num(); cx = num(); cy = num(); points.push({ x: cx, y: cy }); break;
                    case 'a': num(); num(); num(); num(); num(); cx += num(); cy += num(); points.push({ x: cx, y: cy }); break;
                    case 'Z': case 'z': cx = sx; cy = sy; break;
                }
            }
            return points;
        }

        // Color picker with undo tracking
        function setupColorPicker(swatchId, pickerId, getColor, setColor, onUpdate) {
            let undoPushed = false;
            $(swatchId).addEventListener('click', () => {
                $(pickerId).value = rgbToHex(getColor());
                $(pickerId).click();
            });
            $(pickerId).addEventListener('input', e => {
                if (!undoPushed) { pushUndo(); undoPushed = true; }
                setColor(hexToRgb(e.target.value));
                if (onUpdate) onUpdate();
                update();
            });
            $(pickerId).addEventListener('change', () => { undoPushed = false; });
        }

        // Helper to set up exclusive button groups
        // Sliding indicator for btn-groups
        function updateIndicator(group) {
            const active = group.querySelector('.btn.active');
            const indicator = group.querySelector('.btn-group-indicator');
            if (active && indicator) {
                indicator.style.left = active.offsetLeft + 'px';
                indicator.style.width = active.offsetWidth + 'px';
            }
        }

        function initBtnGroupIndicators() {
            document.querySelectorAll('.btn-group').forEach(group => {
                const indicator = document.createElement('div');
                indicator.className = 'btn-group-indicator';
                group.insertBefore(indicator, group.firstChild);
                updateIndicator(group);
            });
        }

        function setupBtnGroup(containerId, onChange) {
            const container = $(containerId);
            container.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateIndicator(container);
                    onChange(btn.dataset.value);
                    update();
                });
            });
        }

        setupBtnGroup('opacityBtns', val => { pushUndo(); viewMode = val; });
        setupBtnGroup('sampleBtns', val => { pushUndo(); sampleMode = val; });

        // Unified slider/input handling
        function syncNM(source, newVal) {
            newVal = Math.min(Math.max(1, newVal || 1), MAX_GRID);
            if (source === 'n') {
                nSlider.value = nInput.value = newVal;
                if (resolutionLocked) mSlider.value = mInput.value = newVal;
            } else {
                mSlider.value = mInput.value = newVal;
                if (resolutionLocked) nSlider.value = nInput.value = newVal;
            }
            update();
        }

        nSlider.addEventListener('input', () => syncNM('n', parseInt(nSlider.value)));
        mSlider.addEventListener('input', () => syncNM('m', parseInt(mSlider.value)));
        nInput.addEventListener('input', () => syncNM('n', parseInt(nInput.value)));
        mInput.addEventListener('input', () => syncNM('m', parseInt(mInput.value)));

        function setupToggle(btnId, getter, setter, useLockIcon = false, bounce = false) {
            const btn = $(btnId);
            btn.addEventListener('click', () => {
                const newVal = !getter();
                setter(newVal);
                // setLockState handles class toggle for lock buttons, otherwise do it here
                if (useLockIcon) setLockState(btnId, newVal);
                else btn.classList.toggle('active', newVal);
                if (bounce) {
                    btn.classList.remove('bounce');
                    void btn.offsetWidth; // reflow to restart animation
                    btn.classList.add('bounce');
                }
                autoSave();
            });
        }

        setupToggle('aspectLock', () => aspectLocked, v => { pushUndo(); aspectLocked = v; if (v) lockedAspectRatio = rect.width / rect.height; }, true);
        setupToggle('resolutionLock', () => resolutionLocked, v => { pushUndo(); resolutionLocked = v; }, false); // chain button, no lock icon swap
        setupToggle('expandMode', () => expandModeOn, v => { pushUndo(); expandModeOn = v; }, false, true);

        setupBtnGroup('tileBtns', val => {
            // Special handling for custom - trigger file picker if no custom shape loaded
            if (val === 'custom' && SHAPES.custom.contours.length === 0) {
                $('customSvgInput').click();
                return;
            }
            pushUndo();
            tileMode = val;
            update();
        });

        // Custom SVG file input handler
        $('customSvgInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const contours = parseSvgForContours(ev.target.result);
                    SHAPES.custom.contours = contours;
                    pushUndo();
                    tileMode = 'custom';
                    nSlider.value = nInput.value = mSlider.value = mInput.value = 1;
                    setBtnGroupValue('tileBtns', 'custom');
                    update();
                } catch (err) {
                    alert('SVG parsing failed: ' + err.message);
                }
            };
            reader.onerror = () => alert('Failed to read SVG file');
            reader.readAsText(file);
            e.target.value = ''; // reset so same file can be reloaded
        });

        // Allow clicking custom button to load new SVG even if one is already loaded
        $('customSvgBtn').addEventListener('dblclick', () => {
            $('customSvgInput').click();
        });

        // Color conversion helpers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 255, 0];
        }

        function rgbToHex([r, g, b]) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Chroma key controls
        function updateChromaSwatch() {
            const [r, g, b] = chromaColor;
            $('chromaSwatchInner').style.background = chromaEnabled ? `rgb(${r},${g},${b})` : 'transparent';
            $('chromaSwatch').style.borderColor = chromaEnabled ? '#e94560' : '#888';
        }

        $('chromaToggle').addEventListener('click', () => {
            pushUndo();
            setChromaEnabled(!chromaEnabled);
            update();
        });

        setupColorPicker('chromaSwatch', 'chromaColorPicker', () => chromaColor, c => {
            chromaColor = c;
            if (!chromaEnabled) setChromaEnabled(true);
            updateChromaSwatch();
        });

        $('eyedropperBtn').addEventListener('click', () => setEyedropperMode(!eyedropperMode));

        let toleranceUndoPushed = false;
        $('chromaTolerance').addEventListener('mousedown', () => { pushUndo(); toleranceUndoPushed = true; });
        $('chromaTolerance').addEventListener('input', e => {
            chromaTolerance = parseInt(e.target.value);
            $('chromaToleranceVal').textContent = chromaTolerance;
            update();
        });
        $('chromaTolerance').addEventListener('mouseup', () => { toleranceUndoPushed = false; });

        updateChromaSwatch();

        // Grid color controls
        function updateGridColorSwatch() {
            $('gridColorSwatchInner').style.background = `rgb(${gridColor.join(',')})`;
        }

        setupColorPicker('gridColorSwatch', 'gridColorPicker', () => gridColor, c => {
            gridColor = c;
            updateGridColorSwatch();
        });

        updateGridColorSwatch();

        // Palette panel functions
        function togglePalettePanel(open) {
            palettePanelOpen = open ?? !palettePanelOpen;
            $('palettePanel').classList.toggle('open', palettePanelOpen);
            $('paletteToggle').classList.toggle('active', palettePanelOpen);
            if (palettePanelOpen) updateToolbarHeight();
        }

        function setPaletteEnabled(enabled) {
            paletteEnabled = enabled;
            $('paletteEnabledBtn').classList.toggle('active', enabled);
            $('paletteEnabledBtn').querySelector('.iconify').dataset.icon = enabled ? 'mdi:checkbox-marked' : 'mdi:checkbox-blank-outline';
        }

        function setPaletteEyedropperMode(enabled) {
            paletteEyedropperMode = enabled;
            $('paletteEyedropperBtn').classList.toggle('active', enabled);
            mainSvg.style.cursor = (enabled || eyedropperMode) ? 'crosshair' : 'default';
        }

        function renderPaletteGrid() {
            const grid = $('paletteGrid');
            grid.innerHTML = '';
            paletteColors.forEach((color, i) => {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.style.background = `rgb(${color.join(',')})`;
                swatch.title = `RGB(${color.join(', ')}) - Click to edit`;

                // Click to edit
                swatch.addEventListener('click', e => {
                    if (e.target.classList.contains('remove-btn')) return;
                    paletteEditingIndex = i;
                    $('paletteColorPicker').value = rgbToHex(color);
                    $('paletteColorPicker').click();
                });

                // Remove button
                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '×';
                removeBtn.addEventListener('click', e => {
                    e.stopPropagation();
                    pushUndo();
                    paletteColors.splice(i, 1);
                    renderPaletteGrid();
                    update();
                });
                swatch.appendChild(removeBtn);

                grid.appendChild(swatch);
            });
            $('paletteColorCount').textContent = paletteColors.length;
        }

        // Palette event handlers
        $('paletteToggle').addEventListener('click', () => togglePalettePanel());
        $('palettePanelClose').addEventListener('click', () => togglePalettePanel(false));

        $('paletteEnabledBtn').addEventListener('click', () => {
            pushUndo();
            setPaletteEnabled(!paletteEnabled);
            update();
        });

        $('addColorPickerBtn').addEventListener('click', () => {
            paletteEditingIndex = -1;
            $('paletteColorPicker').value = '#ff0000';
            $('paletteColorPicker').click();
        });

        $('paletteColorPicker').addEventListener('change', e => {
            pushUndo();
            const color = hexToRgb(e.target.value);
            if (paletteEditingIndex >= 0) {
                paletteColors[paletteEditingIndex] = color;
            } else {
                paletteColors.push(color);
            }
            renderPaletteGrid();
            update();
        });

        $('paletteEyedropperBtn').addEventListener('click', () => {
            setPaletteEyedropperMode(!paletteEyedropperMode);
            if (paletteEyedropperMode) setEyedropperMode(false); // Turn off chroma eyedropper
        });

        $('clearColorsBtn').addEventListener('click', () => {
            if (paletteColors.length === 0) return;
            pushUndo();
            paletteColors = [];
            renderPaletteGrid();
            update();
        });

        // State helpers - used by undo/redo and localStorage
        function getState() {
            return { rect: { ...rect }, n: parseInt(nSlider.value), m: parseInt(mSlider.value),
                viewMode, sampleMode, aspectLocked, lockedAspectRatio, resolutionLocked, expandModeOn,
                nMax: parseInt(nSlider.max), mMax: parseInt(mSlider.max),
                chromaEnabled, chromaColor, chromaTolerance, tileMode, gridColor,
                paletteEnabled, paletteColors: paletteColors.map(c => [...c]),
                customContours: SHAPES.custom.contours.map(c => c.map(p => ({x: p.x, y: p.y}))) };
        }

        function applyState(s) {
            rect = { ...s.rect };
            nSlider.max = mSlider.max = Math.min(s.nMax || 500, 500);
            nSlider.value = nInput.value = Math.min(s.n || 16, 500);
            mSlider.value = mInput.value = Math.min(s.m || 16, 500);
            viewMode = s.viewMode ?? (s.gridOpacity !== undefined ? String(Math.round(s.gridOpacity * 100)) : '100'); // backwards compat
            sampleMode = s.sampleMode ?? 'center';
            aspectLocked = s.aspectLocked ?? true;
            lockedAspectRatio = s.lockedAspectRatio ?? 1;
            resolutionLocked = s.resolutionLocked ?? true;
            expandModeOn = s.expandModeOn ?? false;
            chromaEnabled = s.chromaEnabled ?? false;
            chromaColor = s.chromaColor ?? [0, 255, 0];
            chromaTolerance = s.chromaTolerance ?? 30;
            tileMode = s.tileMode ?? (s.hexMode ? 'hex' : 'square'); // backwards compat
            gridColor = s.gridColor ?? [233, 69, 96];
            paletteEnabled = s.paletteEnabled ?? false;
            paletteColors = (s.paletteColors || []).map(c => [...c]);
            SHAPES.custom.contours = (s.customContours || []).map(c => c.map(p => ({x: p.x, y: p.y})));

            // Update UI
            updateGridColorSwatch();
            setBtnGroupValue('opacityBtns', viewMode);
            setBtnGroupValue('sampleBtns', sampleMode);
            setBtnGroupValue('tileBtns', tileMode);
            setLockState('aspectLock', aspectLocked);
            setLockState('resolutionLock', resolutionLocked);
            $('expandMode').classList.toggle('active', expandModeOn);
            setChromaEnabled(chromaEnabled);
            $('chromaTolerance').value = chromaTolerance;
            $('chromaToleranceVal').textContent = chromaTolerance;
            setPaletteEnabled(paletteEnabled);
            renderPaletteGrid();
        }

        // Undo/redo
        function pushUndo() { undoStack.push(JSON.stringify(getState())); if (undoStack.length > MAX_UNDO) undoStack.shift(); redoStack = []; }
        function undo() { if (!undoStack.length) return; redoStack.push(JSON.stringify(getState())); applyState(JSON.parse(undoStack.pop())); render(); }
        function redo() { if (!redoStack.length) return; undoStack.push(JSON.stringify(getState())); applyState(JSON.parse(redoStack.pop())); render(); }

        $('undoBtn').addEventListener('click', undo);
        $('redoBtn').addEventListener('click', redo);

        // Storage abstraction (IndexedDB for large data)
        const storage = (() => {
            const DB_NAME = 'pixelArtTool';
            const STORE_NAME = 'data';
            let db = null;

            const open = () => new Promise((resolve, reject) => {
                if (db) return resolve(db);
                const req = indexedDB.open(DB_NAME, 1);
                req.onerror = () => reject(req.error);
                req.onsuccess = () => { db = req.result; resolve(db); };
                req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
            });

            return {
                async save(key, value) {
                    const d = await open();
                    return new Promise((resolve, reject) => {
                        const tx = d.transaction(STORE_NAME, 'readwrite');
                        tx.objectStore(STORE_NAME).put(value, key);
                        tx.oncomplete = resolve;
                        tx.onerror = () => reject(tx.error);
                    });
                },
                async load(key) {
                    const d = await open();
                    return new Promise((resolve, reject) => {
                        const tx = d.transaction(STORE_NAME, 'readonly');
                        const req = tx.objectStore(STORE_NAME).get(key);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                }
            };
        })();

        // Auto-save/restore
        async function autoSave() {
            await storage.save('state', getState());
            if (image) {
                const tc = document.createElement('canvas');
                tc.width = image.width; tc.height = image.height;
                tc.getContext('2d').drawImage(image, 0, 0);
                await storage.save('image', tc.toDataURL('image/png'));
            }
        }

        async function autoRestore() {
            const [state, imageData] = await Promise.all([
                storage.load('state'),
                storage.load('image')
            ]);
            if (imageData) {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    imageSrc = imageData;
                    resizeView();
                    dropZone.classList.remove('show-initial');
                    if (state) applyState(state);
                    render();
                };
                img.src = imageData;
            } else if (state) {
                applyState(state);
            }
        }

        // Color sampling
        function sampleCell(imgData, x0, y0, x1, y1, width) {
            x0 = Math.max(0, Math.floor(x0)); y0 = Math.max(0, Math.floor(y0));
            x1 = Math.min(width, Math.floor(x1)); y1 = Math.min(imgData.height, Math.floor(y1));
            if (x1 <= x0 || y1 <= y0) return null;

            if (sampleMode === 'center') {
                const idx = (Math.floor((y0 + y1) / 2) * width + Math.floor((x0 + x1) / 2)) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                const idx = (y * width + x) * 4;
                pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
            }
            return aggregatePixels(pixels);
        }

        // Info field
        function updateInfoField() {
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            $('infoField').value = `x=${rect.x.toFixed(1)} y=${rect.y.toFixed(1)} w=${rect.width.toFixed(1)} h=${rect.height.toFixed(1)} n=${n} m=${m}`;
        }
        $('infoField').addEventListener('click', function() { this.select(); navigator.clipboard.writeText(this.value); });

        // Create export canvas with sampled pixels (shared by save/copy)
        function createExportCanvas() {
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const canvas = document.createElement('canvas');
            canvas.width = n; canvas.height = m;
            const ctx = canvas.getContext('2d');
            const imgData = getImageData();
            const cellW = rect.width / n, cellH = rect.height / m;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                const color = sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, image.width);
                if (color) {
                    const alpha = chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance ? 0 : 1;
                    ctx.fillStyle = `rgba(${color.map(Math.round).join(',')},${alpha})`;
                    ctx.fillRect(col, row, 1, 1);
                }
            }
            return canvas;
        }

        // Save PNG
        $('saveBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const canvas = createExportCanvas();
            const link = document.createElement('a');
            link.download = `pixel_art_x${rect.x.toFixed(0)}_y${rect.y.toFixed(0)}_w${rect.width.toFixed(0)}_h${rect.height.toFixed(0)}_n${n}_m${m}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Copy PNG to clipboard (G key)
        function copyPngToClipboard() {
            if (!image) return;
            createExportCanvas().toBlob(blob => {
                navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
            }, 'image/png');
        }

        // Save SVG - preserves exact tile geometry (uses generic SHAPES)
        $('saveSvgBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const imgData = getImageData();
            const svgW = 800, svgH = 800 * (rect.height / rect.width);
            const scaleX = svgW / rect.width, scaleY = svgH / rect.height;

            const shape = SHAPES[tileMode];
            let paths = '';
            forEachTile(n, m, (col, row, ci, geom) => {
                const tileLocal = shape.getTile(col, row, geom, 0, 0, ci);
                const tileSample = shape.getTile(col, row, geom, rect.x, rect.y, ci);
                const fill = colorToFill(shape.sample(imgData, tileSample, image.width, image.height));
                if (fill) paths += shape.svgTag(tileLocal, scaleX, scaleY, 0, 0) + ` fill="${fill}"/>\n`;
            });

            const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${svgW.toFixed(0)}" height="${svgH.toFixed(0)}" viewBox="0 0 ${svgW.toFixed(0)} ${svgH.toFixed(0)}">\n${paths}</svg>`;
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `pixel_art_${tileMode}_n${n}_m${m}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        });

        // Reset
        $('resetBtn').addEventListener('click', () => {
            nSlider.value = nInput.value = DEFAULT_N;
            mSlider.value = mInput.value = DEFAULT_M;
            if (image) { rect.width = rect.height = DEFAULT_RECT_SIZE; rect.x = (image.width - DEFAULT_RECT_SIZE) / 2; rect.y = (image.height - DEFAULT_RECT_SIZE) / 2; }
            else rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
            aspectLocked = false;
            setLockState('aspectLock', false);
            lockedAspectRatio = 1;
            update();
        });

        // Drag and drop
        container.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('active'); });
        container.addEventListener('dragleave', e => { if (!container.contains(e.relatedTarget)) dropZone.classList.remove('active'); });
        container.addEventListener('drop', e => {
            e.preventDefault(); dropZone.classList.remove('active', 'show-initial');
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('image/')) loadImage(file);
        });

        let imageSrc = null; // data URL for the image

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    imageSrc = e.target.result;
                    resizeView();
                    update();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Single source of truth for display scaling
        // Returns ratio of screen pixels to image pixels (accounting for zoom)
        function getDisplayScale() {
            if (!image) return 1;
            const cr = container.getBoundingClientRect();
            const fitScale = Math.min((cr.width - CONTAINER_PADDING) / image.width, (cr.height - CONTAINER_PADDING) / image.height);
            return fitScale * viewZoom;
        }

        function resizeView() {
            if (!image) return;
            updateView();
            updateMinimap();
        }

        function updateView() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            const displayScale = getDisplayScale();
            // Calculate viewBox for pan/zoom (SVG re-renders at full res)
            const vbW = image.width / viewZoom;
            const vbH = image.height / viewZoom;
            const vbX = -viewOffset.x / displayScale;
            const vbY = -viewOffset.y / displayScale;
            mainSvg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
            // Size SVG to fill container
            mainSvg.style.width = cr.width + 'px';
            mainSvg.style.height = cr.height + 'px';
            wrapper.style.transform = '';
            updateMinimapViewport();
        }

        // Minimap
        const minimap = $('minimap');
        const minimapCanvas = $('minimapCanvas');
        const minimapViewport = $('minimapViewport');

        function updateMinimapViewport() {
            if (!image) { minimap.classList.remove('visible'); return; }
            minimap.classList.add('visible');

            const cr = container.getBoundingClientRect();
            // fitScale is the base scale to fit image in container (without zoom)
            const fitScale = Math.min((cr.width - CONTAINER_PADDING) / image.width, (cr.height - CONTAINER_PADDING) / image.height);
            const displayScale = fitScale * viewZoom;

            // Viewport size in image coords - based on actual container aspect ratio
            const vbW = cr.width / displayScale;
            const vbH = cr.height / displayScale;

            // Viewport position in image coords
            // viewOffset is in screen pixels, convert to image coords
            const vbX = -viewOffset.x / displayScale;
            const vbY = -viewOffset.y / displayScale;

            // Find bounding box that contains both image (0,0,w,h) and viewport
            const minX = Math.min(0, vbX);
            const minY = Math.min(0, vbY);
            const maxX = Math.max(image.width, vbX + vbW);
            const maxY = Math.max(image.height, vbY + vbH);
            const totalW = maxX - minX;
            const totalH = maxY - minY;

            // Scale to fit minimap
            const mmScale = Math.min(MINIMAP_SIZE / totalW, MINIMAP_SIZE / totalH);
            const canvasW = totalW * mmScale;
            const canvasH = totalH * mmScale;

            // Draw image at correct position within the bounding box
            minimapCanvas.width = canvasW;
            minimapCanvas.height = canvasH;
            const ctx = minimapCanvas.getContext('2d');
            ctx.clearRect(0, 0, canvasW, canvasH);
            const imgX = (0 - minX) * mmScale;
            const imgY = (0 - minY) * mmScale;
            ctx.drawImage(image, imgX, imgY, image.width * mmScale, image.height * mmScale);

            // Position viewport rectangle (offset by padding)
            const padding = 2;
            const vpX = (vbX - minX) * mmScale + padding;
            const vpY = (vbY - minY) * mmScale + padding;
            minimapViewport.style.left = vpX + 'px';
            minimapViewport.style.top = vpY + 'px';
            minimapViewport.style.width = (vbW * mmScale) + 'px';
            minimapViewport.style.height = (vbH * mmScale) + 'px';
        }

        function updateMinimap() { updateMinimapViewport(); }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2);
        }

        function medianColor(pixels) {
            const half = pixels.length >> 1;
            return [0, 1, 2].map(i => {
                const bins = new Uint32Array(256);
                for (const p of pixels) bins[p[i]]++;
                let sum = 0;
                for (let v = 0; v < 256; v++) { sum += bins[v]; if (sum > half) return v; }
                return 255;
            });
        }

        // Cache image data to avoid recreating every frame
        let cachedImgData = null;
        let cachedImgDataSrc = null;

        function getImageData() {
            if (cachedImgDataSrc === image.src) return cachedImgData;
            const sampleCanvas = document.createElement('canvas');
            sampleCanvas.width = image.width;
            sampleCanvas.height = image.height;
            const sampleCtx = sampleCanvas.getContext('2d');
            sampleCtx.drawImage(image, 0, 0);
            cachedImgData = sampleCtx.getImageData(0, 0, image.width, image.height);
            cachedImgDataSrc = image.src;
            return cachedImgData;
        }

        // Persistent SVG elements
        let svgElements = { image: null, tiles: null, border: null, handles: [] };
        let lastTileKey = '';

        function initSvgElements() {
            const ns = 'http://www.w3.org/2000/svg';
            mainSvg.innerHTML = '';

            svgElements.image = document.createElementNS(ns, 'image');
            mainSvg.appendChild(svgElements.image);

            svgElements.tiles = document.createElementNS(ns, 'g');
            mainSvg.appendChild(svgElements.tiles);

            svgElements.border = document.createElementNS(ns, 'rect');
            svgElements.border.setAttribute('fill', 'none');
            svgElements.border.setAttribute('vector-effect', 'non-scaling-stroke');
            svgElements.border.setAttribute('stroke-width', '2');
            mainSvg.appendChild(svgElements.border);

            svgElements.handles = [];
            for (let i = 0; i < 4; i++) {
                const h = document.createElementNS(ns, 'rect');
                svgElements.handles.push(h);
                mainSvg.appendChild(h);
            }
        }

        let renderPending = false;
        function render() {
            if (!image || renderPending) return;
            renderPending = true;
            requestAnimationFrame(() => {
                renderPending = false;
                renderNow();
            });
        }

        function renderNow() {
            if (!image) return;
            if (!svgElements.image) initSvgElements();

            const imgData = getImageData();
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const gridColorRgba = `rgba(${gridColor.join(',')},0.5)`;
            const gridColorRgb = `rgb(${gridColor.join(',')})`;
            const vm = VIEW_MODES[viewMode];

            // Update image
            if (svgElements.image.getAttribute('href') !== imageSrc) {
                svgElements.image.setAttribute('href', imageSrc);
                svgElements.image.setAttribute('width', image.width);
                svgElements.image.setAttribute('height', image.height);
            }
            svgElements.image.style.display = vm.showImage ? '' : 'none';

            // Get shape config
            const shape = SHAPES[tileMode];

            // Check if tiles need rebuild (structure changed)
            // For custom shapes, include contour count in key
            const customContourCount = tileMode === 'custom' ? SHAPES.custom.contours.length : 0;
            const tileKey = `${n},${m},${tileMode},${customContourCount}`;
            const tileCount = shape.getTileCount ? shape.getTileCount(n, m) : n * m;
            if (tileKey !== lastTileKey) {
                const ns = 'http://www.w3.org/2000/svg';
                svgElements.tiles.innerHTML = '';
                for (let i = 0; i < tileCount; i++) {
                    const el = document.createElementNS(ns, shape.type);
                    el.setAttribute('vector-effect', 'non-scaling-stroke');
                    el.setAttribute('stroke-width', '1');
                    svgElements.tiles.appendChild(el);
                }
                lastTileKey = tileKey;
            }

            // Update tiles using generic shape handling
            const tiles = svgElements.tiles.children;
            let idx = 0;
            forEachTile(n, m, (col, row, ci, geom) => {
                const tile = shape.getTile(col, row, geom, rect.x, rect.y, ci);
                const el = tiles[idx++];
                shape.setAttrs(el, tile);
                const color = shape.sample(imgData, tile, image.width, image.height);
                el.setAttribute('fill', colorToFill(color, 'transparent') || 'none');
                el.setAttribute('fill-opacity', vm.fillOpacity);
                el.setAttribute('stroke', vm.showStroke ? gridColorRgba : 'none');
            });

            // Apply flip transform to tiles
            const cx = rect.x + rect.width / 2, cy = rect.y + rect.height / 2;
            const sx = rect.flipX ? -1 : 1, sy = rect.flipY ? -1 : 1;
            svgElements.tiles.setAttribute('transform', `translate(${cx},${cy}) scale(${sx},${sy}) translate(${-cx},${-cy})`);

            // Update border
            svgElements.border.setAttribute('x', rect.x);
            svgElements.border.setAttribute('y', rect.y);
            svgElements.border.setAttribute('width', rect.width);
            svgElements.border.setAttribute('height', rect.height);
            svgElements.border.setAttribute('stroke', gridColorRgb);

            updateHandles(gridColorRgb);
            updateView();
            updateInfoField();
        }

        function updateHandles(color) {
            if (!svgElements.handles.length) return;
            const hs = getHandleSizeHit();
            const c = color || `rgb(${gridColor.join(',')})`;
            [[0, 0], [1, 0], [0, 1], [1, 1]].forEach(([cx, cy], i) => {
                const h = svgElements.handles[i];
                h.setAttribute('x', rect.x + cx * rect.width - hs / 2);
                h.setAttribute('y', rect.y + cy * rect.height - hs / 2);
                h.setAttribute('width', hs);
                h.setAttribute('height', hs);
                h.setAttribute('fill', c);
            });
        }

        function getMousePos(e) {
            // Use SVG's built-in coordinate transform (accounts for viewBox and preserveAspectRatio)
            const pt = mainSvg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgPt = pt.matrixTransform(mainSvg.getScreenCTM().inverse());
            return { x: svgPt.x, y: svgPt.y };
        }

        // Handle size in image coords (compensates for scale so handles appear constant on screen)
        function getHandleSizeHit() {
            return HANDLE_SCREEN_PX / getDisplayScale();
        }

        function getHitZone(pos) {
            const hs = getHandleSizeHit();
            const corners = [['tl', 0, 0], ['tr', 1, 0], ['bl', 0, 1], ['br', 1, 1]];
            for (const [id, cx, cy] of corners) {
                if (Math.abs(pos.x - (rect.x + cx * rect.width)) < hs && Math.abs(pos.y - (rect.y + cy * rect.height)) < hs) return id;
            }
            const inX = pos.x > rect.x && pos.x < rect.x + rect.width;
            const inY = pos.y > rect.y && pos.y < rect.y + rect.height;
            if (Math.abs(pos.x - rect.x) < hs && inY) return 'left';
            if (Math.abs(pos.x - rect.x - rect.width) < hs && inY) return 'right';
            if (Math.abs(pos.y - rect.y) < hs && inX) return 'top';
            if (Math.abs(pos.y - rect.y - rect.height) < hs && inX) return 'bottom';
            if (inX && inY) return 'move';
            return null;
        }

        const CURSORS = { tl: 'nwse-resize', br: 'nwse-resize', tr: 'nesw-resize', bl: 'nesw-resize', left: 'ew-resize', right: 'ew-resize', top: 'ns-resize', bottom: 'ns-resize', move: 'move' };

        mainSvg.addEventListener('mousedown', e => {
            const pos = getMousePos(e);

            // Eyedropper mode - pick color from image (chroma key)
            if (eyedropperMode && image) {
                const imgData = getImageData();
                const px = Math.floor(pos.x), py = Math.floor(pos.y);
                if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
                    const idx = (py * image.width + px) * 4;
                    chromaColor = [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                    $('chromaColorPicker').value = rgbToHex(chromaColor);
                    if (!chromaEnabled) setChromaEnabled(true);
                    updateChromaSwatch();
                }
                setEyedropperMode(false);
                update();
                return;
            }

            // Palette eyedropper mode - add color from image
            if (paletteEyedropperMode && image) {
                const imgData = getImageData();
                const px = Math.floor(pos.x), py = Math.floor(pos.y);
                if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
                    pushUndo();
                    const idx = (py * image.width + px) * 4;
                    paletteColors.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    renderPaletteGrid();
                }
                setPaletteEyedropperMode(false);
                update();
                return;
            }

            dragging = getHitZone(pos);
            if (dragging) {
                document.body.classList.add('dragging');
                pushUndo();
                dragStart = pos;
                rectStart = { ...rect };
                nStart = parseInt(nSlider.value);
                mStart = parseInt(mSlider.value);
                if (aspectLocked) lockedAspectRatio = rect.width / rect.height;
            }
        });

        mainSvg.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            mainSvg.style.cursor = (eyedropperMode || paletteEyedropperMode) ? 'crosshair' : (CURSORS[getHitZone(pos)] || 'default');
        });

        window.addEventListener('mousemove', e => {
            if (!dragging) return;

            const pos = getMousePos(e);
            let dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            if (e.shiftKey) { dx /= 10; dy /= 10; }
            if (e.ctrlKey || e.metaKey) { if (Math.abs(dx) > Math.abs(dy)) dy = 0; else dx = 0; }

            if (dragging === 'move') {
                let newX = rectStart.x + dx, newY = rectStart.y + dy;
                if (expandModeOn && !e.shiftKey) {
                    // Snap relative to original position based on tile geometry
                    const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);
                    const snappedDx = Math.round(dx / snap.dx) * snap.dx;
                    const snappedDy = Math.round(dy / snap.dy) * snap.dy;
                    newX = rectStart.x + snappedDx;
                    newY = rectStart.y + snappedDy;
                }
                rect.x = newX; rect.y = newY;
            } else if (expandModeOn) {
                handleExpandResize(dx, dy);
            } else {
                // Edges always use free resize (axis-locked), corners use aspect resize if locked
                const isEdge = ['left', 'right', 'top', 'bottom'].includes(dragging);
                if (aspectLocked && !isEdge) {
                    handleAspectResize(dx, dy);
                } else {
                    handleFreeResize(dx, dy);
                }
            }
            render();
        });

        // Get snap units for each tile mode - how much to move per tile add/remove
        function getTileSnapUnits(n, m, w, h) {
            const g = SHAPES[tileMode];
            const cellW = w / g.wF(n), cellH = h / g.hF(m);
            return { dx: cellW * g.snapW, dy: cellH * g.snapH };
        }

        // Calculate new rect dimensions when adding/removing tiles
        function calcExpandedRect(newN, newM, anchorX, anchorY) {
            const g = SHAPES[tileMode];
            const cellW = rectStart.width / g.wF(nStart), cellH = rectStart.height / g.hF(mStart);
            const newW = cellW * g.wF(newN), newH = cellH * g.hF(newM);
            return {
                x: anchorX ? rectStart.x + rectStart.width - newW : rectStart.x,
                y: anchorY ? rectStart.y + rectStart.height - newH : rectStart.y,
                width: newW, height: newH
            };
        }

        function handleExpandResize(dx, dy) {
            const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);

            // Direction multipliers: [dxSign, dySign, anchorX, anchorY]
            const cfg = {
                br: [1, 1, 0, 0], tl: [-1, -1, 1, 1], tr: [1, -1, 0, 1], bl: [-1, 1, 1, 0],
                right: [1, 0, 0, 0], left: [-1, 0, 1, 0], bottom: [0, 1, 0, 0], top: [0, -1, 0, 1]
            }[dragging];
            if (!cfg) return;

            const [dxs, dys, ax, ay] = cfg;

            // Only compute cell deltas for axes that this handle affects
            const cellDx = dxs ? Math.round(dx / snap.dx) : 0;
            const cellDy = dys ? Math.round(dy / snap.dy) : 0;

            const newN = Math.min(Math.max(1, nStart + dxs * cellDx), MAX_GRID);
            const newM = Math.min(Math.max(1, mStart + dys * cellDy), MAX_GRID);

            const newRect = calcExpandedRect(newN, newM, ax, ay);
            if (dxs) { rect.width = newRect.width; rect.x = newRect.x; nSlider.value = nInput.value = newN; }
            if (dys) { rect.height = newRect.height; rect.y = newRect.y; mSlider.value = mInput.value = newM; }
        }

        // Normalize rect so width/height are always positive (flip x/y as needed)
        function normalizeRect() {
            if (rect.width < 0) { rect.x += rect.width; rect.width = -rect.width; }
            if (rect.height < 0) { rect.y += rect.height; rect.height = -rect.height; }
        }

        function handleAspectResize(dx, dy) {
            const sf = Math.max(Math.abs(dx) / rectStart.width, Math.abs(dy) / rectStart.height);

            if (['br', 'tl', 'tr', 'bl'].includes(dragging)) {
                const signs = { br: dx + dy, tl: -(dx + dy), tr: dx - dy, bl: -dx + dy };
                const sign = signs[dragging] > 0 ? 1 : -1;
                const newW = rectStart.width * (1 + sign * sf);
                const newH = newW / lockedAspectRatio;
                rect.width = newW; rect.height = newH;
                if (dragging[0] === 't') rect.y = rectStart.y + rectStart.height - newH;
                if (dragging[1] === 'l') rect.x = rectStart.x + rectStart.width - newW;
            } else {
                // Edge resize - scale from opposite edge center
                const isHoriz = dragging === 'left' || dragging === 'right';
                const delta = isHoriz ? dx : dy;
                const fromStart = dragging === 'left' || dragging === 'top';

                if (isHoriz) {
                    const newW = rectStart.width + (fromStart ? -delta : delta);
                    const newH = newW / lockedAspectRatio;
                    const centerY = rectStart.y + rectStart.height / 2;
                    rect.width = newW; rect.height = newH; rect.y = centerY - newH / 2;
                    if (fromStart) rect.x = rectStart.x + rectStart.width - newW;
                } else {
                    const newH = rectStart.height + (fromStart ? -delta : delta);
                    const newW = newH * lockedAspectRatio;
                    const centerX = rectStart.x + rectStart.width / 2;
                    rect.width = newW; rect.height = newH; rect.x = centerX - newW / 2;
                    if (fromStart) rect.y = rectStart.y + rectStart.height - newH;
                }
            }
            normalizeRect();
        }

        function handleFreeResize(dx, dy) {
            // For corners (tl, tr, bl, br): check character position
            // For edges (left, right, top, bottom): exact match only
            const isLeft = dragging === 'left' || dragging === 'tl' || dragging === 'bl';
            const isRight = dragging === 'right' || dragging === 'tr' || dragging === 'br';
            const isTop = dragging === 'top' || dragging === 'tl' || dragging === 'tr';
            const isBottom = dragging === 'bottom' || dragging === 'bl' || dragging === 'br';

            // Calculate new bounds based on which edge/corner is being dragged
            let x0 = rectStart.x, y0 = rectStart.y;
            let x1 = rectStart.x + rectStart.width, y1 = rectStart.y + rectStart.height;

            if (isLeft) x0 = rectStart.x + dx;
            if (isRight) x1 = rectStart.x + rectStart.width + dx;
            if (isTop) y0 = rectStart.y + dy;
            if (isBottom) y1 = rectStart.y + rectStart.height + dy;

            // Track flip state and normalize
            rect.flipX = x1 < x0;
            rect.flipY = y1 < y0;
            rect.x = Math.min(x0, x1);
            rect.y = Math.min(y0, y1);
            rect.width = Math.abs(x1 - x0);
            rect.height = Math.abs(y1 - y0);
        }

        window.addEventListener('mouseup', () => { if (dragging) autoSave(); dragging = null; document.body.classList.remove('dragging'); });
        window.addEventListener('resize', () => { if (image) { resizeView(); render(); } });

        // Trackpad pan/zoom: two-finger scroll = pan, pinch = zoom
        container.addEventListener('wheel', e => {
            if (!image) return;
            e.preventDefault();

            const cr = container.getBoundingClientRect();
            const mouseX = e.clientX - cr.left;
            const mouseY = e.clientY - cr.top;

            if (e.ctrlKey) {
                // Pinch-to-zoom (ctrlKey is set by macOS during pinch gestures)
                const zoomFactor = 1 - e.deltaY * 0.01;
                const newZoom = Math.min(Math.max(0.1, viewZoom * zoomFactor), 20);

                // Zoom towards mouse position (relative to container center)
                const baseScale = getDisplayScale() / viewZoom; // scale without zoom
                const displayW = image.width * baseScale;
                const displayH = image.height * baseScale;
                const centerX = (cr.width - displayW) / 2;
                const centerY = (cr.height - displayH) / 2;

                // Current position in view space
                const viewX = mouseX - centerX - viewOffset.x;
                const viewY = mouseY - centerY - viewOffset.y;

                // Scale the offset to zoom towards cursor
                const scale = newZoom / viewZoom;
                viewOffset.x += viewX - viewX * scale;
                viewOffset.y += viewY - viewY * scale;
                viewZoom = newZoom;
                updateHandles();
                updateMinimap();
            } else {
                // Two-finger pan
                viewOffset.x -= e.deltaX;
                viewOffset.y -= e.deltaY;
            }
            updateView();
        }, { passive: false });

        // Double-click to reset view
        mainSvg.addEventListener('dblclick', e => {
            if (!image) return;
            viewZoom = 1;
            viewOffset = { x: 0, y: 0 };
            updateHandles();
            updateView();
            updateMinimap();
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', e => {
            if ('12345'.includes(e.key)) {
                pushUndo();
                const modes = { '1': '0', '2': '50', '3': '100', '4': 'tiles', '5': 'solo' };
                viewMode = modes[e.key];
                setBtnGroupValue('opacityBtns', viewMode);
                update();
            } else if (e.key.toLowerCase() === 's') { e.preventDefault(); $('saveSvgBtn').click(); }
            else if (e.key.toLowerCase() === 'g') { e.preventDefault(); copyPngToClipboard(); }
            else if (e.key.toLowerCase() === 'x') { $('expandMode').click(); }
            else if (e.key.toLowerCase() === 'h') {
                pushUndo();
                const modes = ['square', 'hex', 'hexV', 'tri', 'triH'];
                tileMode = modes[(modes.indexOf(tileMode) + 1) % modes.length];
                setBtnGroupValue('tileBtns', tileMode);
                update();
            }
            else if (e.key.toLowerCase() === 'e') { $('eyedropperBtn').click(); }
            else if (e.key.toLowerCase() === 'c') { $('chromaToggle').click(); }
            else if (e.key.toLowerCase() === 'p') { togglePalettePanel(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        autoRestore();
        initBtnGroupIndicators();

        // Glassify elements - adds liquid glass styling
        function glassify(selector) {
            document.querySelectorAll(selector).forEach(el => {
                el.style.position = 'relative';
                el.style.background = 'var(--glass-bg)';
                el.style.border = '1px solid var(--glass-border)';
                el.style.backdropFilter = 'blur(4px)';
                el.style.webkitBackdropFilter = 'blur(4px)';
                el.style.boxShadow = 'var(--glass-shadow)';

                // Add highlight overlays if not already present
                if (!el.querySelector('.glass-highlight')) {
                    const before = document.createElement('div');
                    before.className = 'glass-highlight';
                    before.style.cssText = 'position:absolute;inset:0;border-radius:inherit;background:linear-gradient(135deg,rgba(255,255,255,0.12) 0%,transparent 50%);pointer-events:none;';
                    const after = document.createElement('div');
                    after.className = 'glass-highlight';
                    after.style.cssText = 'position:absolute;inset:0;border-radius:inherit;background:linear-gradient(315deg,rgba(255,255,255,0.06) 0%,transparent 50%);pointer-events:none;';
                    el.insertBefore(after, el.firstChild);
                    el.insertBefore(before, el.firstChild);
                }
            });
        }

        // Apply glass styling to elements
        glassify('.btn:not(.btn-group .btn)');
        glassify('.icon-btn');
        glassify('.num-input');
        glassify('#infoField');
        glassify('.chroma-group');

        // Update palette panel position based on toolbar height
        function updateToolbarHeight() {
            const toolbar = document.querySelector('.controls');
            if (toolbar) {
                document.documentElement.style.setProperty('--toolbar-height', toolbar.offsetHeight + 'px');
            }
        }
        window.addEventListener('resize', updateToolbarHeight);
    </script>
</body>
</html>

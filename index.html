<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Alignment Tool</title>
    <script src="https://code.iconify.design/3/3.1.0/iconify.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .controls {
            padding: 15px 20px;
            background: #16213e;
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #0f3460;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label { font-size: 14px; color: #aaa; }
        .control-group input[type="range"] { width: 200px; cursor: pointer; }
        .btn {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #0f3460;
            color: #eee;
            transition: all 0.2s;
        }
        .btn:hover { background: #1a4a7a; }
        .btn.active { background: #e94560; color: white; }
        .btn.accent { background: #e94560; }
        .icon-btn {
            background: #0f3460;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 6px 10px;
            color: #888;
            transition: all 0.2s;
            font-size: 16px;
        }
        .icon-btn:hover { background: #1a4a7a; }
        .icon-btn.active { color: #e94560; }
        .btn-group { display: flex; gap: 5px; }
        .slider-group { display: flex; align-items: center; gap: 8px; }
        .slider-pair { display: flex; flex-direction: column; gap: 6px; }
        .num-input {
            width: 50px;
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 4px;
            border-radius: 4px;
            text-align: center;
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #canvasWrapper {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }
        #mainSvg { display: block; overflow: visible; }
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(26, 26, 46, 0.9);
            border: 3px dashed #e94560;
            margin: 20px;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .drop-zone.active, .drop-zone.show-initial { opacity: 1; }
        .drop-zone.show-initial { pointer-events: auto; }
        .drop-zone p { font-size: 24px; color: #e94560; }
        .instructions {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            color: #888;
            max-width: 300px;
        }
        #infoField {
            background: #0f3460;
            border: none;
            color: #e94560;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 320px;
            cursor: pointer;
        }
        .chroma-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 4px;
        }
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid #888;
            cursor: pointer;
            background: conic-gradient(#808080 25%, #fff 25% 50%, #808080 50% 75%, #fff 75%);
            background-size: 8px 8px;
        }
        .color-swatch-inner {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }
        .color-picker-hidden {
            position: absolute;
            width: 0;
            height: 0;
            opacity: 0;
            pointer-events: none;
        }
        .chroma-slider {
            width: 80px;
        }
        /* Palette panel */
        .palette-panel {
            position: fixed;
            top: 60px;
            right: 0;
            width: 260px;
            max-height: calc(100vh - 80px);
            background: #16213e;
            border-left: 1px solid #0f3460;
            border-bottom: 1px solid #0f3460;
            border-radius: 0 0 0 8px;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }
        .palette-panel.open { transform: translateX(0); }
        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #0f3460;
            background: #0f3460;
        }
        .palette-header span { font-size: 14px; font-weight: 500; }
        .palette-toggle, .palette-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-bottom: 1px solid #0f3460;
        }
        .palette-toggle label { font-size: 13px; color: #aaa; }
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            align-content: start;
            min-height: 80px;
        }
        .palette-swatch {
            aspect-ratio: 1;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            position: relative;
            transition: border-color 0.1s;
        }
        .palette-swatch:hover { border-color: #e94560; }
        .palette-swatch .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 14px;
            height: 14px;
            background: #e94560;
            border-radius: 50%;
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            color: white;
            display: none;
            cursor: pointer;
        }
        .palette-swatch:hover .remove-btn { display: block; }
        .palette-stats {
            padding: 8px 15px;
            font-size: 12px;
            color: #888;
            border-top: 1px solid #0f3460;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group slider-group">
            <div class="slider-pair">
                <div class="control-group">
                    <label style="width: 60px;">N (cols):</label>
                    <input type="range" id="nSlider" min="1" max="500" value="16">
                    <input type="number" id="nInput" min="1" max="500" value="16" class="num-input">
                </div>
                <div class="control-group">
                    <label style="width: 60px;">M (rows):</label>
                    <input type="range" id="mSlider" min="1" max="500" value="16">
                    <input type="number" id="mInput" min="1" max="500" value="16" class="num-input">
                </div>
            </div>
            <button class="icon-btn active" id="resolutionLock" title="Lock N:M ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Aspect:</label>
            <button class="icon-btn active" id="aspectLock" title="Lock rectangle aspect ratio">
                <svg width="16" height="24" viewBox="0 0 16 24" fill="currentColor">
                    <path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/>
                    <rect x="2" y="8" width="12" height="10" rx="2"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Grid Opacity:</label>
            <div class="btn-group" id="opacityBtns">
                <button class="btn" data-value="0">0%</button>
                <button class="btn" data-value="50">50%</button>
                <button class="btn active" data-value="100">100%</button>
                <button class="btn" data-value="tiles" title="Tiles only (no grid lines)">Tiles</button>
                <button class="btn" data-value="solo" title="Tiles only (no image)">Solo</button>
            </div>
        </div>
        <div class="control-group">
            <label>Sample:</label>
            <div class="btn-group" id="sampleBtns">
                <button class="btn active" data-value="center">Center</button>
                <button class="btn" data-value="mean">Mean</button>
                <button class="btn" data-value="median">Median</button>
            </div>
        </div>
        <div class="control-group">
            <label>Expand:</label>
            <button class="icon-btn" id="expandMode" title="Expand mode: resize by adding/removing cells">
                <svg width="18" height="18" viewBox="0 0 18 18" fill="currentColor">
                    <rect x="1" y="1" width="5" height="5" rx="1"/>
                    <rect x="7" y="1" width="5" height="5" rx="1"/>
                    <rect x="1" y="7" width="5" height="5" rx="1"/>
                    <rect x="7" y="7" width="5" height="5" rx="1" opacity="0.4"/>
                    <rect x="13" y="7" width="4" height="5" rx="1" opacity="0.4"/>
                    <rect x="7" y="13" width="5" height="4" rx="1" opacity="0.4"/>
                </svg>
            </button>
        </div>
        <div class="control-group">
            <label>Tiles:</label>
            <div class="btn-group" id="tileBtns">
                <button class="btn active" data-value="square" title="Square tiles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><rect x="1" y="1" width="12" height="12"/></svg>
                </button>
                <button class="btn" data-value="hex" title="Flat-top hexagon (H)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M4 1H10L13 7L10 13H4L1 7L4 1Z"/></svg>
                </button>
                <button class="btn" data-value="hexV" title="Pointy-top hexagon">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 0.5L13 4V10L7 13.5L1 10V4L7 0.5Z"/></svg>
                </button>
                <button class="btn" data-value="tri" title="Equilateral triangles">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M7 1L13 13H1L7 1Z"/></svg>
                </button>
                <button class="btn" data-value="triH" title="Horizontal triangles (rotated 90°)">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="currentColor"><path d="M1 7L13 1V13L1 7Z"/></svg>
                </button>
            </div>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="undoBtn" title="Undo (Ctrl+Z)">
                <span class="iconify" data-icon="mdi:undo" data-width="20"></span>
            </button>
            <button class="icon-btn" id="redoBtn" title="Redo (Ctrl+Y)">
                <span class="iconify" data-icon="mdi:redo" data-width="20"></span>
            </button>
        </div>
        <div class="control-group">
            <button class="btn" id="resetBtn">Reset Grid</button>
        </div>
        <div class="control-group">
            <button class="btn accent" id="saveBtn">Save PNG</button>
            <button class="btn accent" id="saveSvgBtn">Save SVG</button>
        </div>
        <div class="control-group">
            <input type="text" id="infoField" readonly title="Click to copy">
        </div>
        <div class="control-group">
            <label>Grid:</label>
            <div class="color-swatch" id="gridColorSwatch" title="Grid/border color">
                <div class="color-swatch-inner" id="gridColorSwatchInner" style="background:#e94560"></div>
            </div>
            <input type="color" id="gridColorPicker" class="color-picker-hidden" value="#e94560">
        </div>
        <div class="control-group chroma-group">
            <label>Chroma:</label>
            <button class="icon-btn" id="chromaToggle" title="Enable chroma key">
                <span class="iconify" data-icon="mdi:eye-off" data-width="18"></span>
            </button>
            <div class="color-swatch" id="chromaSwatch" title="Click to pick color">
                <div class="color-swatch-inner" id="chromaSwatchInner"></div>
            </div>
            <input type="color" id="chromaColorPicker" class="color-picker-hidden" value="#00ff00">
            <button class="icon-btn" id="eyedropperBtn" title="Pick color from image (E)">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <input type="range" id="chromaTolerance" min="0" max="150" value="30" class="chroma-slider" title="Color tolerance">
            <span id="chromaToleranceVal" style="min-width: 25px; font-size: 12px; color: #e94560;">30</span>
        </div>
        <div class="control-group">
            <button class="icon-btn" id="paletteToggle" title="Color Palette (P)">
                <span class="iconify" data-icon="mdi:palette" data-width="20"></span>
            </button>
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <div id="canvasWrapper">
            <svg id="mainSvg"></svg>
        </div>
        <div class="drop-zone show-initial" id="dropZone">
            <p>Drop an image here</p>
        </div>
    </div>

    <div class="instructions">
        Drag corners to resize the pixel grid. Drag inside to move it. Use sliders to change grid dimensions.
    </div>

    <!-- Palette Panel -->
    <div class="palette-panel" id="palettePanel">
        <div class="palette-header">
            <span>Color Palette</span>
            <button class="icon-btn" id="palettePanelClose" style="padding: 4px 8px;">×</button>
        </div>
        <div class="palette-toggle">
            <button class="icon-btn" id="paletteEnabledBtn" title="Enable palette restriction">
                <span class="iconify" data-icon="mdi:checkbox-blank-outline" data-width="18"></span>
            </button>
            <label>Restrict to palette</label>
        </div>
        <div class="palette-controls">
            <button class="btn" id="addColorPickerBtn" title="Add color via picker">+ Color</button>
            <button class="icon-btn" id="paletteEyedropperBtn" title="Pick color from image">
                <span class="iconify" data-icon="mdi:eyedropper" data-width="18"></span>
            </button>
            <button class="btn" id="clearColorsBtn">Clear</button>
        </div>
        <div class="palette-grid" id="paletteGrid"></div>
        <div class="palette-stats"><span id="paletteColorCount">0</span> colors</div>
    </div>
    <input type="color" id="paletteColorPicker" class="color-picker-hidden">

    <script>
        const $ = id => document.getElementById(id);
        const mainSvg = $('mainSvg');
        const container = $('canvasContainer');
        const wrapper = $('canvasWrapper');
        const dropZone = $('dropZone');
        const nSlider = $('nSlider'), mSlider = $('mSlider');
        const nInput = $('nInput'), mInput = $('mInput');

        // Global constants
        const MAX_GRID = 500;
        const MAX_UNDO = 50;
        const DEFAULT_N = 16, DEFAULT_M = 16;
        const DEFAULT_RECT_SIZE = 200;
        const MIN_RECT_SIZE = 20;
        const RETINA = window.devicePixelRatio || 1;

        let image = null;
        let viewMode = '100'; // '0', '50', '100', 'tiles', 'solo'
        const VIEW_MODES = {
            '0':     { fillOpacity: 0,   showStroke: true,  showImage: true },
            '50':    { fillOpacity: 0.5, showStroke: true,  showImage: true },
            '100':   { fillOpacity: 1,   showStroke: true,  showImage: true },
            'tiles': { fillOpacity: 1,   showStroke: false, showImage: true },
            'solo':  { fillOpacity: 1,   showStroke: false, showImage: false }
        };
        let sampleMode = 'center';
        let rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
        let dragging = null;
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, width: 0, height: 0 };
        let nStart = DEFAULT_N, mStart = DEFAULT_M;

        let undoStack = [], redoStack = [];

        let aspectLocked = true, lockedAspectRatio = 1;
        let resolutionLocked = true, expandModeOn = false;

        // Chroma key state
        let chromaEnabled = false;
        let chromaColor = [0, 255, 0]; // RGB
        let chromaTolerance = 30;
        let eyedropperMode = false;
        let tileMode = 'square'; // 'square', 'hex', 'hexV', 'tri', 'triH'
        let gridColor = [233, 69, 96]; // RGB for #e94560

        // Palette state
        let paletteEnabled = false;
        let paletteColors = []; // Array of [r,g,b]
        let palettePanelOpen = false;
        let paletteEyedropperMode = false;
        let paletteEditingIndex = -1; // -1 = adding new, >= 0 = editing existing

        // View transform state (pan/zoom for the whole canvas view)
        let viewOffset = { x: 0, y: 0 };
        let viewZoom = 1;

        // === HELPER FUNCTIONS ===
        function update() { render(); autoSave(); }

        function setBtnGroupValue(groupId, value) {
            $(groupId).querySelectorAll('.btn').forEach(b => b.classList.toggle('active', b.dataset.value == value));
        }

        function setChromaEnabled(enabled) {
            chromaEnabled = enabled;
            $('chromaToggle').classList.toggle('active', enabled);
            $('chromaToggle').querySelector('.iconify').dataset.icon = enabled ? 'mdi:eye' : 'mdi:eye-off';
            updateChromaSwatch();
        }

        function setEyedropperMode(enabled) {
            eyedropperMode = enabled;
            $('eyedropperBtn').classList.toggle('active', enabled);
            mainSvg.style.cursor = enabled ? 'crosshair' : 'default';
        }

        function setLockState(btnId, locked) {
            const btn = $(btnId);
            btn.classList.toggle('active', locked);
            btn.querySelector('svg').innerHTML = locked ? LOCK_CLOSED : LOCK_OPEN;
        }

        function aggregatePixels(pixels) {
            if (!pixels.length) return null;
            if (sampleMode === 'mean') {
                const sum = pixels.reduce((a, p) => [a[0] + p[0], a[1] + p[1], a[2] + p[2]], [0, 0, 0]);
                return sum.map(v => v / pixels.length);
            }
            return medianColor(pixels);
        }

        function colorToFill(color, nullValue = null) {
            if (!color) return nullValue;
            if (chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance) {
                return nullValue;
            }
            // Apply palette restriction
            if (paletteEnabled && paletteColors.length) {
                color = nearestPaletteColor(color);
            }
            return `rgb(${color[0]|0},${color[1]|0},${color[2]|0})`;
        }

        function nearestPaletteColor([r, g, b]) {
            let minDist = Infinity, nearest = [r, g, b];
            for (const pc of paletteColors) {
                const d = colorDistance(r, g, b, pc[0], pc[1], pc[2]);
                if (d < minDist) { minDist = d; nearest = pc; }
            }
            return nearest;
        }

        // Point-in-shape test functions (shared utilities)
        function pointInHex(px, py, cx, cy, halfW, halfH) {
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            return halfH * halfW - halfH * dx - halfW * 0.5 * dy >= 0;
        }
        function pointInHexV(px, py, cx, cy, halfW, halfH) {
            const dx = Math.abs(px - cx), dy = Math.abs(py - cy);
            if (dx > halfW || dy > halfH) return false;
            return halfW * halfH - halfW * dy - halfH * 0.5 * dx >= 0;
        }
        function pointInTriangle(px, py, x0, y0, x1, y1, x2, y2) {
            const area = 0.5 * (-y1 * x2 + y0 * (-x1 + x2) + x0 * (y1 - y2) + x1 * y2);
            const s = 1 / (2 * area) * (y0 * x2 - x0 * y2 + (y2 - y0) * px + (x0 - x2) * py);
            const t = 1 / (2 * area) * (x0 * y1 - y0 * x1 + (y0 - y1) * px + (x1 - x0) * py);
            return s >= 0 && t >= 0 && (1 - s - t) >= 0;
        }

        // Unified shape definitions - each shape defines its geometry, tile generation, and sampling
        const SHAPES = {
            square: {
                type: 'rect',
                wF: n => n, hF: m => m, snapW: 1, snapH: 1,
                getGeometry: (n, m, w, h) => ({ cellW: w / n, cellH: h / m }),
                getTile: (col, row, g, ox, oy) => {
                    const x = ox + col * g.cellW, y = oy + row * g.cellH;
                    return { x, y, width: g.cellW, height: g.cellH, cx: x + g.cellW / 2, cy: y + g.cellH / 2 };
                },
                sample: (imgData, t, w, h) => {
                    if (sampleMode === 'center') {
                        const idx = (Math.floor(t.cy) * w + Math.floor(t.cx)) * 4;
                        return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
                    }
                    const x0 = Math.max(0, Math.floor(t.x)), y0 = Math.max(0, Math.floor(t.y));
                    const x1 = Math.min(w, Math.floor(t.x + t.width)), y1 = Math.min(h, Math.floor(t.y + t.height));
                    const pixels = [];
                    for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                        const idx = (y * w + x) * 4;
                        pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    }
                    return aggregatePixels(pixels);
                },
                setAttrs: (el, t) => { el.setAttribute('x', t.x); el.setAttribute('y', t.y); el.setAttribute('width', t.width); el.setAttribute('height', t.height); },
                svgTag: (t, sx, sy) => `<rect x="${(t.x * sx).toFixed(2)}" y="${(t.y * sy).toFixed(2)}" width="${(t.width * sx).toFixed(2)}" height="${(t.height * sy).toFixed(2)}"`
            },
            hex: {
                type: 'polygon',
                wF: n => n * 0.75 + 0.25, hF: m => m + 0.5, snapW: 0.75, snapH: 1,
                getGeometry: (n, m, w, h) => {
                    const hexW = w / (n * 0.75 + 0.25), hexH = h / (m + 0.5);
                    return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
                },
                getTile: (col, row, g, ox, oy) => {
                    const cx = ox + col * g.hexW * 0.75 + g.halfW;
                    const cy = oy + row * g.hexH + (col % 2 === 1 ? g.halfH : 0) + g.halfH;
                    return { cx, cy, halfW: g.halfW, halfH: g.halfH,
                        points: `${cx + g.halfW},${cy} ${cx + g.halfW * 0.5},${cy - g.halfH} ${cx - g.halfW * 0.5},${cy - g.halfH} ${cx - g.halfW},${cy} ${cx - g.halfW * 0.5},${cy + g.halfH} ${cx + g.halfW * 0.5},${cy + g.halfH}` };
                },
                sample: (imgData, t, w, h) => {
                    if (sampleMode === 'center') {
                        const idx = (Math.floor(t.cy) * w + Math.floor(t.cx)) * 4;
                        return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
                    }
                    const x0 = Math.max(0, Math.floor(t.cx - t.halfW)), y0 = Math.max(0, Math.floor(t.cy - t.halfH));
                    const x1 = Math.min(w, Math.ceil(t.cx + t.halfW)), y1 = Math.min(h, Math.ceil(t.cy + t.halfH));
                    const pixels = [];
                    for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                        if (pointInHex(x + 0.5, y + 0.5, t.cx, t.cy, t.halfW, t.halfH)) {
                            const idx = (y * w + x) * 4;
                            pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                        }
                    }
                    return aggregatePixels(pixels);
                },
                setAttrs: (el, t) => el.setAttribute('points', t.points),
                svgTag: (t, sx, sy, ox, oy) => {
                    const cx = t.cx - ox, cy = t.cy - oy;
                    const pts = [[cx + t.halfW, cy], [cx + t.halfW * 0.5, cy - t.halfH], [cx - t.halfW * 0.5, cy - t.halfH], [cx - t.halfW, cy], [cx - t.halfW * 0.5, cy + t.halfH], [cx + t.halfW * 0.5, cy + t.halfH]];
                    return `<polygon points="${pts.map(([x, y]) => `${(x * sx).toFixed(2)},${(y * sy).toFixed(2)}`).join(' ')}"`;
                }
            },
            hexV: {
                type: 'polygon',
                wF: n => n + 0.5, hF: m => m * 0.75 + 0.25, snapW: 1, snapH: 0.75,
                getGeometry: (n, m, w, h) => {
                    const hexW = w / (n + 0.5), hexH = h / (m * 0.75 + 0.25);
                    return { hexW, hexH, halfW: hexW / 2, halfH: hexH / 2 };
                },
                getTile: (col, row, g, ox, oy) => {
                    const cx = ox + col * g.hexW + (row % 2 === 1 ? g.halfW : 0) + g.halfW;
                    const cy = oy + row * g.hexH * 0.75 + g.halfH;
                    return { cx, cy, halfW: g.halfW, halfH: g.halfH,
                        points: `${cx},${cy - g.halfH} ${cx + g.halfW},${cy - g.halfH * 0.5} ${cx + g.halfW},${cy + g.halfH * 0.5} ${cx},${cy + g.halfH} ${cx - g.halfW},${cy + g.halfH * 0.5} ${cx - g.halfW},${cy - g.halfH * 0.5}` };
                },
                sample: (imgData, t, w, h) => {
                    if (sampleMode === 'center') {
                        const idx = (Math.floor(t.cy) * w + Math.floor(t.cx)) * 4;
                        return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
                    }
                    const x0 = Math.max(0, Math.floor(t.cx - t.halfW)), y0 = Math.max(0, Math.floor(t.cy - t.halfH));
                    const x1 = Math.min(w, Math.ceil(t.cx + t.halfW)), y1 = Math.min(h, Math.ceil(t.cy + t.halfH));
                    const pixels = [];
                    for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                        if (pointInHexV(x + 0.5, y + 0.5, t.cx, t.cy, t.halfW, t.halfH)) {
                            const idx = (y * w + x) * 4;
                            pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                        }
                    }
                    return aggregatePixels(pixels);
                },
                setAttrs: (el, t) => el.setAttribute('points', t.points),
                svgTag: (t, sx, sy, ox, oy) => {
                    const cx = t.cx - ox, cy = t.cy - oy;
                    const pts = [[cx, cy - t.halfH], [cx + t.halfW, cy - t.halfH * 0.5], [cx + t.halfW, cy + t.halfH * 0.5], [cx, cy + t.halfH], [cx - t.halfW, cy + t.halfH * 0.5], [cx - t.halfW, cy - t.halfH * 0.5]];
                    return `<polygon points="${pts.map(([x, y]) => `${(x * sx).toFixed(2)},${(y * sy).toFixed(2)}`).join(' ')}"`;
                }
            },
            tri: {
                type: 'polygon',
                wF: n => (n + 1) / 2, hF: m => m, snapW: 0.5, snapH: 1,
                getGeometry: (n, m, w, h) => ({ triW: w / ((n + 1) / 2), triH: h / m }),
                getTile: (col, row, g, ox, oy) => {
                    const isUp = (col + row) % 2 === 0;
                    const baseX = ox + col * g.triW / 2, baseY = oy + row * g.triH;
                    if (isUp) return { x0: baseX + g.triW / 2, y0: baseY, x1: baseX, y1: baseY + g.triH, x2: baseX + g.triW, y2: baseY + g.triH, cx: baseX + g.triW / 2, cy: baseY + g.triH * 2 / 3 };
                    return { x0: baseX, y0: baseY, x1: baseX + g.triW, y1: baseY, x2: baseX + g.triW / 2, y2: baseY + g.triH, cx: baseX + g.triW / 2, cy: baseY + g.triH / 3 };
                },
                sample: (imgData, t, w, h) => {
                    if (sampleMode === 'center') {
                        const idx = (Math.floor(t.cy) * w + Math.floor(t.cx)) * 4;
                        return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
                    }
                    const minX = Math.max(0, Math.floor(Math.min(t.x0, t.x1, t.x2))), maxX = Math.min(w, Math.ceil(Math.max(t.x0, t.x1, t.x2)));
                    const minY = Math.max(0, Math.floor(Math.min(t.y0, t.y1, t.y2))), maxY = Math.min(h, Math.ceil(Math.max(t.y0, t.y1, t.y2)));
                    const pixels = [];
                    for (let y = minY; y < maxY; y++) for (let x = minX; x < maxX; x++) {
                        if (pointInTriangle(x + 0.5, y + 0.5, t.x0, t.y0, t.x1, t.y1, t.x2, t.y2)) {
                            const idx = (y * w + x) * 4;
                            pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                        }
                    }
                    return aggregatePixels(pixels);
                },
                setAttrs: (el, t) => el.setAttribute('points', `${t.x0},${t.y0} ${t.x1},${t.y1} ${t.x2},${t.y2}`),
                svgTag: (t, sx, sy, ox, oy) => `<polygon points="${[(t.x0-ox)*sx,(t.y0-oy)*sy,(t.x1-ox)*sx,(t.y1-oy)*sy,(t.x2-ox)*sx,(t.y2-oy)*sy].map(v=>v.toFixed(2)).join(',')}"`
            },
            triH: {
                type: 'polygon',
                wF: n => n, hF: m => (m + 1) / 2, snapW: 1, snapH: 0.5,
                getGeometry: (n, m, w, h) => ({ triW: w / n, triH: h / ((m + 1) / 2) }),
                getTile: (col, row, g, ox, oy) => {
                    // Alternate left/right based on (col + row) % 2
                    const isRight = (col + row) % 2 === 0;
                    const baseX = ox + col * g.triW, baseY = oy + row * g.triH / 2;
                    if (isRight) return { x0: baseX, y0: baseY, x1: baseX, y1: baseY + g.triH, x2: baseX + g.triW, y2: baseY + g.triH / 2, cx: baseX + g.triW * 2 / 3, cy: baseY + g.triH / 2 };
                    return { x0: baseX + g.triW, y0: baseY, x1: baseX + g.triW, y1: baseY + g.triH, x2: baseX, y2: baseY + g.triH / 2, cx: baseX + g.triW / 3, cy: baseY + g.triH / 2 };
                },
                sample: (imgData, t, w, h) => {
                    if (sampleMode === 'center') {
                        const idx = (Math.floor(t.cy) * w + Math.floor(t.cx)) * 4;
                        return (idx >= 0 && idx < imgData.data.length - 3) ? [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]] : null;
                    }
                    const minX = Math.max(0, Math.floor(Math.min(t.x0, t.x1, t.x2))), maxX = Math.min(w, Math.ceil(Math.max(t.x0, t.x1, t.x2)));
                    const minY = Math.max(0, Math.floor(Math.min(t.y0, t.y1, t.y2))), maxY = Math.min(h, Math.ceil(Math.max(t.y0, t.y1, t.y2)));
                    const pixels = [];
                    for (let y = minY; y < maxY; y++) for (let x = minX; x < maxX; x++) {
                        if (pointInTriangle(x + 0.5, y + 0.5, t.x0, t.y0, t.x1, t.y1, t.x2, t.y2)) {
                            const idx = (y * w + x) * 4;
                            pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                        }
                    }
                    return aggregatePixels(pixels);
                },
                setAttrs: (el, t) => el.setAttribute('points', `${t.x0},${t.y0} ${t.x1},${t.y1} ${t.x2},${t.y2}`),
                svgTag: (t, sx, sy, ox, oy) => `<polygon points="${[(t.x0-ox)*sx,(t.y0-oy)*sy,(t.x1-ox)*sx,(t.y1-oy)*sy,(t.x2-ox)*sx,(t.y2-oy)*sy].map(v=>v.toFixed(2)).join(',')}"`
            }
        };

        // Lock icon SVG paths (moved up for setLockState)
        const LOCK_CLOSED = '<path d="M4 8h2V6a2 2 0 114 0v2h2V6a4 4 0 10-8 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';
        const LOCK_OPEN = '<path d="M12 8h-2V6a2 2 0 10-4 0v2H4V6a4 4 0 118 0v2z"/><rect x="2" y="8" width="12" height="10" rx="2"/>';

        // Color picker with undo tracking
        function setupColorPicker(swatchId, pickerId, getColor, setColor, onUpdate) {
            let undoPushed = false;
            $(swatchId).addEventListener('click', () => {
                $(pickerId).value = rgbToHex(getColor());
                $(pickerId).click();
            });
            $(pickerId).addEventListener('input', e => {
                if (!undoPushed) { pushUndo(); undoPushed = true; }
                setColor(hexToRgb(e.target.value));
                if (onUpdate) onUpdate();
                update();
            });
            $(pickerId).addEventListener('change', () => { undoPushed = false; });
        }

        // Helper to set up exclusive button groups
        function setupBtnGroup(containerId, onChange) {
            const container = $(containerId);
            container.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    onChange(btn.dataset.value);
                    update();
                });
            });
        }

        setupBtnGroup('opacityBtns', val => { pushUndo(); viewMode = val; });
        setupBtnGroup('sampleBtns', val => { pushUndo(); sampleMode = val; });

        // Unified slider/input handling
        function syncNM(source, newVal) {
            newVal = Math.min(Math.max(1, newVal || 1), MAX_GRID);
            if (source === 'n') {
                nSlider.value = nInput.value = newVal;
                if (resolutionLocked) mSlider.value = mInput.value = newVal;
            } else {
                mSlider.value = mInput.value = newVal;
                if (resolutionLocked) nSlider.value = nInput.value = newVal;
            }
            update();
        }

        nSlider.addEventListener('input', () => syncNM('n', parseInt(nSlider.value)));
        mSlider.addEventListener('input', () => syncNM('m', parseInt(mSlider.value)));
        nInput.addEventListener('input', () => syncNM('n', parseInt(nInput.value)));
        mInput.addEventListener('input', () => syncNM('m', parseInt(mInput.value)));

        function setupToggle(btnId, getter, setter, useLockIcon = false) {
            const btn = $(btnId);
            btn.addEventListener('click', () => {
                const newVal = !getter();
                setter(newVal);
                btn.classList.toggle('active', newVal);
                if (useLockIcon) setLockState(btnId, newVal);
                autoSave();
            });
        }

        setupToggle('aspectLock', () => aspectLocked, v => { pushUndo(); aspectLocked = v; if (v) lockedAspectRatio = rect.width / rect.height; }, true);
        setupToggle('resolutionLock', () => resolutionLocked, v => { pushUndo(); resolutionLocked = v; }, true);
        setupToggle('expandMode', () => expandModeOn, v => { pushUndo(); expandModeOn = v; });

        setupBtnGroup('tileBtns', val => { pushUndo(); tileMode = val; update(); });

        // Color conversion helpers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 255, 0];
        }

        function rgbToHex([r, g, b]) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Chroma key controls
        function updateChromaSwatch() {
            const [r, g, b] = chromaColor;
            $('chromaSwatchInner').style.background = chromaEnabled ? `rgb(${r},${g},${b})` : 'transparent';
            $('chromaSwatch').style.borderColor = chromaEnabled ? '#e94560' : '#888';
        }

        $('chromaToggle').addEventListener('click', () => {
            pushUndo();
            setChromaEnabled(!chromaEnabled);
            update();
        });

        setupColorPicker('chromaSwatch', 'chromaColorPicker', () => chromaColor, c => {
            chromaColor = c;
            if (!chromaEnabled) setChromaEnabled(true);
            updateChromaSwatch();
        });

        $('eyedropperBtn').addEventListener('click', () => setEyedropperMode(!eyedropperMode));

        let toleranceUndoPushed = false;
        $('chromaTolerance').addEventListener('mousedown', () => { pushUndo(); toleranceUndoPushed = true; });
        $('chromaTolerance').addEventListener('input', e => {
            chromaTolerance = parseInt(e.target.value);
            $('chromaToleranceVal').textContent = chromaTolerance;
            update();
        });
        $('chromaTolerance').addEventListener('mouseup', () => { toleranceUndoPushed = false; });

        updateChromaSwatch();

        // Grid color controls
        function updateGridColorSwatch() {
            $('gridColorSwatchInner').style.background = `rgb(${gridColor.join(',')})`;
        }

        setupColorPicker('gridColorSwatch', 'gridColorPicker', () => gridColor, c => {
            gridColor = c;
            updateGridColorSwatch();
        });

        updateGridColorSwatch();

        // Palette panel functions
        function togglePalettePanel(open) {
            palettePanelOpen = open ?? !palettePanelOpen;
            $('palettePanel').classList.toggle('open', palettePanelOpen);
            $('paletteToggle').classList.toggle('active', palettePanelOpen);
        }

        function setPaletteEnabled(enabled) {
            paletteEnabled = enabled;
            $('paletteEnabledBtn').classList.toggle('active', enabled);
            $('paletteEnabledBtn').querySelector('.iconify').dataset.icon = enabled ? 'mdi:checkbox-marked' : 'mdi:checkbox-blank-outline';
        }

        function setPaletteEyedropperMode(enabled) {
            paletteEyedropperMode = enabled;
            $('paletteEyedropperBtn').classList.toggle('active', enabled);
            mainSvg.style.cursor = (enabled || eyedropperMode) ? 'crosshair' : 'default';
        }

        function renderPaletteGrid() {
            const grid = $('paletteGrid');
            grid.innerHTML = '';
            paletteColors.forEach((color, i) => {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.style.background = `rgb(${color.join(',')})`;
                swatch.title = `RGB(${color.join(', ')}) - Click to edit`;

                // Click to edit
                swatch.addEventListener('click', e => {
                    if (e.target.classList.contains('remove-btn')) return;
                    paletteEditingIndex = i;
                    $('paletteColorPicker').value = rgbToHex(color);
                    $('paletteColorPicker').click();
                });

                // Remove button
                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '×';
                removeBtn.addEventListener('click', e => {
                    e.stopPropagation();
                    pushUndo();
                    paletteColors.splice(i, 1);
                    renderPaletteGrid();
                    update();
                });
                swatch.appendChild(removeBtn);

                grid.appendChild(swatch);
            });
            $('paletteColorCount').textContent = paletteColors.length;
        }

        // Palette event handlers
        $('paletteToggle').addEventListener('click', () => togglePalettePanel());
        $('palettePanelClose').addEventListener('click', () => togglePalettePanel(false));

        $('paletteEnabledBtn').addEventListener('click', () => {
            pushUndo();
            setPaletteEnabled(!paletteEnabled);
            update();
        });

        $('addColorPickerBtn').addEventListener('click', () => {
            paletteEditingIndex = -1;
            $('paletteColorPicker').value = '#ff0000';
            $('paletteColorPicker').click();
        });

        $('paletteColorPicker').addEventListener('change', e => {
            pushUndo();
            const color = hexToRgb(e.target.value);
            if (paletteEditingIndex >= 0) {
                paletteColors[paletteEditingIndex] = color;
            } else {
                paletteColors.push(color);
            }
            renderPaletteGrid();
            update();
        });

        $('paletteEyedropperBtn').addEventListener('click', () => {
            setPaletteEyedropperMode(!paletteEyedropperMode);
            if (paletteEyedropperMode) setEyedropperMode(false); // Turn off chroma eyedropper
        });

        $('clearColorsBtn').addEventListener('click', () => {
            if (paletteColors.length === 0) return;
            pushUndo();
            paletteColors = [];
            renderPaletteGrid();
            update();
        });

        // State helpers - used by undo/redo and localStorage
        function getState() {
            return { rect: { ...rect }, n: parseInt(nSlider.value), m: parseInt(mSlider.value),
                viewMode, sampleMode, aspectLocked, lockedAspectRatio, resolutionLocked, expandModeOn,
                nMax: parseInt(nSlider.max), mMax: parseInt(mSlider.max),
                chromaEnabled, chromaColor, chromaTolerance, tileMode, gridColor,
                paletteEnabled, paletteColors: paletteColors.map(c => [...c]) };
        }

        function applyState(s) {
            rect = { ...s.rect };
            nSlider.max = mSlider.max = Math.min(s.nMax || 500, 500);
            nSlider.value = nInput.value = Math.min(s.n || 16, 500);
            mSlider.value = mInput.value = Math.min(s.m || 16, 500);
            viewMode = s.viewMode ?? (s.gridOpacity !== undefined ? String(Math.round(s.gridOpacity * 100)) : '100'); // backwards compat
            sampleMode = s.sampleMode ?? 'center';
            aspectLocked = s.aspectLocked ?? true;
            lockedAspectRatio = s.lockedAspectRatio ?? 1;
            resolutionLocked = s.resolutionLocked ?? true;
            expandModeOn = s.expandModeOn ?? false;
            chromaEnabled = s.chromaEnabled ?? false;
            chromaColor = s.chromaColor ?? [0, 255, 0];
            chromaTolerance = s.chromaTolerance ?? 30;
            tileMode = s.tileMode ?? (s.hexMode ? 'hex' : 'square'); // backwards compat
            gridColor = s.gridColor ?? [233, 69, 96];
            paletteEnabled = s.paletteEnabled ?? false;
            paletteColors = (s.paletteColors || []).map(c => [...c]);

            // Update UI
            updateGridColorSwatch();
            setBtnGroupValue('opacityBtns', viewMode);
            setBtnGroupValue('sampleBtns', sampleMode);
            setBtnGroupValue('tileBtns', tileMode);
            setLockState('aspectLock', aspectLocked);
            setLockState('resolutionLock', resolutionLocked);
            $('expandMode').classList.toggle('active', expandModeOn);
            setChromaEnabled(chromaEnabled);
            $('chromaTolerance').value = chromaTolerance;
            $('chromaToleranceVal').textContent = chromaTolerance;
            setPaletteEnabled(paletteEnabled);
            renderPaletteGrid();
        }

        // Undo/redo
        function pushUndo() { undoStack.push(JSON.stringify(getState())); if (undoStack.length > MAX_UNDO) undoStack.shift(); redoStack = []; }
        function undo() { if (!undoStack.length) return; redoStack.push(JSON.stringify(getState())); applyState(JSON.parse(undoStack.pop())); render(); }
        function redo() { if (!redoStack.length) return; undoStack.push(JSON.stringify(getState())); applyState(JSON.parse(redoStack.pop())); render(); }

        $('undoBtn').addEventListener('click', undo);
        $('redoBtn').addEventListener('click', redo);

        // LocalStorage
        function autoSave() {
            localStorage.setItem('pixelArtToolState', JSON.stringify(getState()));
            if (image) {
                const tc = document.createElement('canvas');
                tc.width = image.width; tc.height = image.height;
                tc.getContext('2d').drawImage(image, 0, 0);
                localStorage.setItem('pixelArtToolImage', tc.toDataURL('image/png'));
            }
        }

        function loadFromLocalStorage() {
            const stateJson = localStorage.getItem('pixelArtToolState');
            const imageData = localStorage.getItem('pixelArtToolImage');
            if (imageData) {
                const img = new Image();
                img.onload = () => { image = img; imageSrc = imageData; resizeView(); dropZone.classList.remove('show-initial'); if (stateJson) applyState(JSON.parse(stateJson)); render(); };
                img.src = imageData;
            } else if (stateJson) applyState(JSON.parse(stateJson));
        }

        // Color sampling
        function sampleCell(imgData, x0, y0, x1, y1, width) {
            x0 = Math.max(0, Math.floor(x0)); y0 = Math.max(0, Math.floor(y0));
            x1 = Math.min(width, Math.floor(x1)); y1 = Math.min(imgData.height, Math.floor(y1));
            if (x1 <= x0 || y1 <= y0) return null;

            if (sampleMode === 'center') {
                const idx = (Math.floor((y0 + y1) / 2) * width + Math.floor((x0 + x1) / 2)) * 4;
                return [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
            }

            const pixels = [];
            for (let y = y0; y < y1; y++) for (let x = x0; x < x1; x++) {
                const idx = (y * width + x) * 4;
                pixels.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
            }
            return aggregatePixels(pixels);
        }

        // Info field
        function updateInfoField() {
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            $('infoField').value = `x=${rect.x.toFixed(1)} y=${rect.y.toFixed(1)} w=${rect.width.toFixed(1)} h=${rect.height.toFixed(1)} n=${n} m=${m}`;
        }
        $('infoField').addEventListener('click', function() { this.select(); navigator.clipboard.writeText(this.value); });

        // Save PNG
        $('saveBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const outCanvas = document.createElement('canvas');
            outCanvas.width = n; outCanvas.height = m;
            const outCtx = outCanvas.getContext('2d');

            const imgData = getImageData();

            const cellW = rect.width / n, cellH = rect.height / m;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                const color = sampleCell(imgData, rect.x + col * cellW, rect.y + row * cellH, rect.x + (col + 1) * cellW, rect.y + (row + 1) * cellH, image.width);
                if (color) {
                    // Apply chroma key to saved image (hard threshold)
                    const alpha = chromaEnabled && colorDistance(color[0], color[1], color[2], chromaColor[0], chromaColor[1], chromaColor[2]) <= chromaTolerance ? 0 : 1;
                    outCtx.fillStyle = `rgba(${color.map(Math.round).join(',')},${alpha})`;
                    outCtx.fillRect(col, row, 1, 1);
                }
            }

            const link = document.createElement('a');
            link.download = `pixel_art_x${rect.x.toFixed(0)}_y${rect.y.toFixed(0)}_w${rect.width.toFixed(0)}_h${rect.height.toFixed(0)}_n${n}_m${m}.png`;
            link.href = outCanvas.toDataURL('image/png');
            link.click();
        });

        // Save SVG - preserves exact tile geometry (uses generic SHAPES)
        $('saveSvgBtn').addEventListener('click', () => {
            if (!image) return;
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const imgData = getImageData();
            const svgW = 800, svgH = 800 * (rect.height / rect.width);
            const scaleX = svgW / rect.width, scaleY = svgH / rect.height;

            const shape = SHAPES[tileMode];
            const geom = shape.getGeometry(n, m, rect.width, rect.height);
            let paths = '';

            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                // Get tile at origin (0,0) for SVG output coords
                const tileLocal = shape.getTile(col, row, geom, 0, 0);
                // Get tile at actual rect position for sampling
                const tileSample = shape.getTile(col, row, geom, rect.x, rect.y);
                const fill = colorToFill(shape.sample(imgData, tileSample, image.width, image.height));
                if (fill) paths += shape.svgTag(tileLocal, scaleX, scaleY, 0, 0) + ` fill="${fill}"/>\n`;
            }

            const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${svgW.toFixed(0)}" height="${svgH.toFixed(0)}" viewBox="0 0 ${svgW.toFixed(0)} ${svgH.toFixed(0)}">\n${paths}</svg>`;
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `pixel_art_${tileMode}_n${n}_m${m}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        });

        // Reset
        $('resetBtn').addEventListener('click', () => {
            nSlider.value = nInput.value = DEFAULT_N;
            mSlider.value = mInput.value = DEFAULT_M;
            if (image) { rect.width = rect.height = DEFAULT_RECT_SIZE; rect.x = (image.width - DEFAULT_RECT_SIZE) / 2; rect.y = (image.height - DEFAULT_RECT_SIZE) / 2; }
            else rect = { x: 100, y: 100, width: DEFAULT_RECT_SIZE, height: DEFAULT_RECT_SIZE };
            aspectLocked = false;
            setLockState('aspectLock', false);
            lockedAspectRatio = 1;
            update();
        });

        // Drag and drop
        container.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('active'); });
        container.addEventListener('dragleave', e => { if (!container.contains(e.relatedTarget)) dropZone.classList.remove('active'); });
        container.addEventListener('drop', e => {
            e.preventDefault(); dropZone.classList.remove('active', 'show-initial');
            const file = e.dataTransfer.files[0];
            if (file?.type.startsWith('image/')) loadImage(file);
        });

        let imageSrc = null; // data URL for the image

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    imageSrc = e.target.result;
                    resizeView();
                    update();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        let canvasScale = 1; // scale from image coords to display coords

        function resizeView() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            canvasScale = Math.min((cr.width - 40) / image.width, (cr.height - 40) / image.height, 1);
            updateView();
        }

        function updateView() {
            if (!image) return;
            const cr = container.getBoundingClientRect();
            // Calculate viewBox for pan/zoom (SVG re-renders at full res)
            const vbW = image.width / viewZoom;
            const vbH = image.height / viewZoom;
            const vbX = -viewOffset.x / (canvasScale * viewZoom);
            const vbY = -viewOffset.y / (canvasScale * viewZoom);
            mainSvg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
            // Size SVG to fill container
            mainSvg.style.width = cr.width + 'px';
            mainSvg.style.height = cr.height + 'px';
            wrapper.style.transform = '';
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2);
        }

        function medianColor(pixels) {
            const half = pixels.length >> 1;
            return [0, 1, 2].map(i => {
                const bins = new Uint32Array(256);
                for (const p of pixels) bins[p[i]]++;
                let sum = 0;
                for (let v = 0; v < 256; v++) { sum += bins[v]; if (sum > half) return v; }
                return 255;
            });
        }

        // Cache image data to avoid recreating every frame
        let cachedImgData = null;
        let cachedImgDataSrc = null;

        function getImageData() {
            if (cachedImgDataSrc === image.src) return cachedImgData;
            const sampleCanvas = document.createElement('canvas');
            sampleCanvas.width = image.width;
            sampleCanvas.height = image.height;
            const sampleCtx = sampleCanvas.getContext('2d');
            sampleCtx.drawImage(image, 0, 0);
            cachedImgData = sampleCtx.getImageData(0, 0, image.width, image.height);
            cachedImgDataSrc = image.src;
            return cachedImgData;
        }

        // Persistent SVG elements
        let svgElements = { image: null, tiles: null, border: null, handles: [] };
        let lastTileKey = '';

        function initSvgElements() {
            const ns = 'http://www.w3.org/2000/svg';
            mainSvg.innerHTML = '';

            svgElements.image = document.createElementNS(ns, 'image');
            mainSvg.appendChild(svgElements.image);

            svgElements.tiles = document.createElementNS(ns, 'g');
            mainSvg.appendChild(svgElements.tiles);

            svgElements.border = document.createElementNS(ns, 'rect');
            svgElements.border.setAttribute('fill', 'none');
            svgElements.border.setAttribute('vector-effect', 'non-scaling-stroke');
            svgElements.border.setAttribute('stroke-width', '2');
            mainSvg.appendChild(svgElements.border);

            svgElements.handles = [];
            for (let i = 0; i < 4; i++) {
                const h = document.createElementNS(ns, 'rect');
                svgElements.handles.push(h);
                mainSvg.appendChild(h);
            }
        }

        let renderPending = false;
        function render() {
            if (!image || renderPending) return;
            renderPending = true;
            requestAnimationFrame(() => {
                renderPending = false;
                renderNow();
            });
        }

        function renderNow() {
            if (!image) return;
            if (!svgElements.image) initSvgElements();

            const imgData = getImageData();
            const n = parseInt(nSlider.value), m = parseInt(mSlider.value);
            const fastMode = dragging !== null;
            const gridColorRgba = `rgba(${gridColor.join(',')},0.5)`;
            const gridColorRgb = `rgb(${gridColor.join(',')})`;
            const vm = VIEW_MODES[viewMode];

            // Update image
            if (svgElements.image.getAttribute('href') !== imageSrc) {
                svgElements.image.setAttribute('href', imageSrc);
                svgElements.image.setAttribute('width', image.width);
                svgElements.image.setAttribute('height', image.height);
            }
            svgElements.image.style.display = vm.showImage ? '' : 'none';

            // Get shape config
            const shape = SHAPES[tileMode];

            // Check if tiles need rebuild (structure changed)
            const tileKey = `${n},${m},${tileMode}`;
            if (tileKey !== lastTileKey) {
                const ns = 'http://www.w3.org/2000/svg';
                svgElements.tiles.innerHTML = '';
                for (let i = 0; i < n * m; i++) {
                    const el = document.createElementNS(ns, shape.type);
                    el.setAttribute('vector-effect', 'non-scaling-stroke');
                    el.setAttribute('stroke-width', '1');
                    svgElements.tiles.appendChild(el);
                }
                lastTileKey = tileKey;
            }

            // Update tiles using generic shape handling
            const tiles = svgElements.tiles.children;
            const geom = shape.getGeometry(n, m, rect.width, rect.height);
            let idx = 0;
            for (let row = 0; row < m; row++) for (let col = 0; col < n; col++) {
                const tile = shape.getTile(col, row, geom, rect.x, rect.y);
                const el = tiles[idx++];
                shape.setAttrs(el, tile);
                const color = fastMode ?
                    (() => { const px = Math.floor(tile.cx), py = Math.floor(tile.cy);
                        return (px >= 0 && px < image.width && py >= 0 && py < image.height) ?
                            [imgData.data[(py * image.width + px) * 4], imgData.data[(py * image.width + px) * 4 + 1], imgData.data[(py * image.width + px) * 4 + 2]] : null; })() :
                    shape.sample(imgData, tile, image.width, image.height);
                el.setAttribute('fill', colorToFill(color, 'transparent') || 'none');
                el.setAttribute('fill-opacity', vm.fillOpacity);
                el.setAttribute('stroke', vm.showStroke ? gridColorRgba : 'none');
            }

            // Update border
            svgElements.border.setAttribute('x', rect.x);
            svgElements.border.setAttribute('y', rect.y);
            svgElements.border.setAttribute('width', rect.width);
            svgElements.border.setAttribute('height', rect.height);
            svgElements.border.setAttribute('stroke', gridColorRgb);

            updateHandles(gridColorRgb);
            updateView();
            updateInfoField();
        }

        function updateHandles(color) {
            if (!svgElements.handles.length) return;
            const hs = getHandleSizeHit();
            const c = color || `rgb(${gridColor.join(',')})`;
            [[0, 0], [1, 0], [0, 1], [1, 1]].forEach(([cx, cy], i) => {
                const h = svgElements.handles[i];
                h.setAttribute('x', rect.x + cx * rect.width - hs / 2);
                h.setAttribute('y', rect.y + cy * rect.height - hs / 2);
                h.setAttribute('width', hs);
                h.setAttribute('height', hs);
                h.setAttribute('fill', c);
            });
        }

        function getMousePos(e) {
            // Use SVG's built-in coordinate transform (accounts for viewBox and preserveAspectRatio)
            const pt = mainSvg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgPt = pt.matrixTransform(mainSvg.getScreenCTM().inverse());
            return { x: svgPt.x, y: svgPt.y };
        }

        // Handle size in image coords (compensates for zoom so handles appear constant on screen)
        const HANDLE_SCREEN_PX = 12;
        function getHandleSizeHit() {
            return HANDLE_SCREEN_PX / (canvasScale * viewZoom);
        }

        function getHitZone(pos) {
            const hs = getHandleSizeHit();
            const corners = [['tl', 0, 0], ['tr', 1, 0], ['bl', 0, 1], ['br', 1, 1]];
            for (const [id, cx, cy] of corners) {
                if (Math.abs(pos.x - (rect.x + cx * rect.width)) < hs && Math.abs(pos.y - (rect.y + cy * rect.height)) < hs) return id;
            }
            const inX = pos.x > rect.x && pos.x < rect.x + rect.width;
            const inY = pos.y > rect.y && pos.y < rect.y + rect.height;
            if (Math.abs(pos.x - rect.x) < hs && inY) return 'left';
            if (Math.abs(pos.x - rect.x - rect.width) < hs && inY) return 'right';
            if (Math.abs(pos.y - rect.y) < hs && inX) return 'top';
            if (Math.abs(pos.y - rect.y - rect.height) < hs && inX) return 'bottom';
            if (inX && inY) return 'move';
            return null;
        }

        const CURSORS = { tl: 'nwse-resize', br: 'nwse-resize', tr: 'nesw-resize', bl: 'nesw-resize', left: 'ew-resize', right: 'ew-resize', top: 'ns-resize', bottom: 'ns-resize', move: 'move' };

        mainSvg.addEventListener('mousedown', e => {
            const pos = getMousePos(e);

            // Eyedropper mode - pick color from image (chroma key)
            if (eyedropperMode && image) {
                const imgData = getImageData();
                const px = Math.floor(pos.x), py = Math.floor(pos.y);
                if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
                    const idx = (py * image.width + px) * 4;
                    chromaColor = [imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]];
                    $('chromaColorPicker').value = rgbToHex(chromaColor);
                    if (!chromaEnabled) setChromaEnabled(true);
                    updateChromaSwatch();
                }
                setEyedropperMode(false);
                update();
                return;
            }

            // Palette eyedropper mode - add color from image
            if (paletteEyedropperMode && image) {
                const imgData = getImageData();
                const px = Math.floor(pos.x), py = Math.floor(pos.y);
                if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
                    pushUndo();
                    const idx = (py * image.width + px) * 4;
                    paletteColors.push([imgData.data[idx], imgData.data[idx + 1], imgData.data[idx + 2]]);
                    renderPaletteGrid();
                }
                setPaletteEyedropperMode(false);
                update();
                return;
            }

            dragging = getHitZone(pos);
            if (dragging) {
                pushUndo();
                dragStart = pos;
                rectStart = { ...rect };
                nStart = parseInt(nSlider.value);
                mStart = parseInt(mSlider.value);
                if (aspectLocked) lockedAspectRatio = rect.width / rect.height;
            }
        });

        mainSvg.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            mainSvg.style.cursor = (eyedropperMode || paletteEyedropperMode) ? 'crosshair' : (CURSORS[getHitZone(pos)] || 'default');
        });

        window.addEventListener('mousemove', e => {
            if (!dragging) return;

            const pos = getMousePos(e);
            let dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            if (e.shiftKey) { dx /= 10; dy /= 10; }
            if (e.ctrlKey || e.metaKey) { if (Math.abs(dx) > Math.abs(dy)) dy = 0; else dx = 0; }

            if (dragging === 'move') {
                let newX = rectStart.x + dx, newY = rectStart.y + dy;
                if (expandModeOn && !e.shiftKey) {
                    // Snap relative to original position based on tile geometry
                    const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);
                    const snappedDx = Math.round(dx / snap.dx) * snap.dx;
                    const snappedDy = Math.round(dy / snap.dy) * snap.dy;
                    newX = rectStart.x + snappedDx;
                    newY = rectStart.y + snappedDy;
                }
                rect.x = newX; rect.y = newY;
            } else if (expandModeOn) {
                handleExpandResize(dx, dy);
            } else {
                // Edges always use free resize (axis-locked), corners use aspect resize if locked
                const isEdge = ['left', 'right', 'top', 'bottom'].includes(dragging);
                if (aspectLocked && !isEdge) {
                    handleAspectResize(dx, dy);
                } else {
                    handleFreeResize(dx, dy);
                }
            }
            render();
        });

        // Get snap units for each tile mode - how much to move per tile add/remove
        function getTileSnapUnits(n, m, w, h) {
            const g = SHAPES[tileMode];
            const cellW = w / g.wF(n), cellH = h / g.hF(m);
            return { dx: cellW * g.snapW, dy: cellH * g.snapH };
        }

        // Calculate new rect dimensions when adding/removing tiles
        function calcExpandedRect(newN, newM, anchorX, anchorY) {
            const g = SHAPES[tileMode];
            const cellW = rectStart.width / g.wF(nStart), cellH = rectStart.height / g.hF(mStart);
            const newW = cellW * g.wF(newN), newH = cellH * g.hF(newM);
            return {
                x: anchorX ? rectStart.x + rectStart.width - newW : rectStart.x,
                y: anchorY ? rectStart.y + rectStart.height - newH : rectStart.y,
                width: newW, height: newH
            };
        }

        function handleExpandResize(dx, dy) {
            const snap = getTileSnapUnits(nStart, mStart, rectStart.width, rectStart.height);

            // Direction multipliers: [dxSign, dySign, anchorX, anchorY]
            const cfg = {
                br: [1, 1, 0, 0], tl: [-1, -1, 1, 1], tr: [1, -1, 0, 1], bl: [-1, 1, 1, 0],
                right: [1, 0, 0, 0], left: [-1, 0, 1, 0], bottom: [0, 1, 0, 0], top: [0, -1, 0, 1]
            }[dragging];
            if (!cfg) return;

            const [dxs, dys, ax, ay] = cfg;

            // Only compute cell deltas for axes that this handle affects
            const cellDx = dxs ? Math.round(dx / snap.dx) : 0;
            const cellDy = dys ? Math.round(dy / snap.dy) : 0;

            const newN = Math.min(Math.max(1, nStart + dxs * cellDx), MAX_GRID);
            const newM = Math.min(Math.max(1, mStart + dys * cellDy), MAX_GRID);

            const newRect = calcExpandedRect(newN, newM, ax, ay);
            if (dxs) { rect.width = newRect.width; rect.x = newRect.x; nSlider.value = nInput.value = newN; }
            if (dys) { rect.height = newRect.height; rect.y = newRect.y; mSlider.value = mInput.value = newM; }
        }

        function handleAspectResize(dx, dy) {
            const sf = Math.max(Math.abs(dx) / rectStart.width, Math.abs(dy) / rectStart.height);

            if (['br', 'tl', 'tr', 'bl'].includes(dragging)) {
                const signs = { br: dx + dy, tl: -(dx + dy), tr: dx - dy, bl: -dx + dy };
                const sign = signs[dragging] > 0 ? 1 : -1;
                const newW = Math.max(MIN_RECT_SIZE, rectStart.width * (1 + sign * sf));
                const newH = newW / lockedAspectRatio;
                rect.width = newW; rect.height = newH;
                if (dragging[0] === 't') rect.y = rectStart.y + rectStart.height - newH;
                if (dragging[1] === 'l') rect.x = rectStart.x + rectStart.width - newW;
            } else {
                // Edge resize - scale from opposite edge center
                const isHoriz = dragging === 'left' || dragging === 'right';
                const delta = isHoriz ? dx : dy;
                const fromStart = dragging === 'left' || dragging === 'top';

                if (isHoriz) {
                    const newW = Math.max(MIN_RECT_SIZE, rectStart.width + (fromStart ? -delta : delta));
                    const newH = newW / lockedAspectRatio;
                    const centerY = rectStart.y + rectStart.height / 2;
                    rect.width = newW; rect.height = newH; rect.y = centerY - newH / 2;
                    if (fromStart) rect.x = rectStart.x + rectStart.width - newW;
                } else {
                    // Vertical edge - anchor top for bottom, anchor bottom for top
                    const newH = Math.max(MIN_RECT_SIZE, rectStart.height + (fromStart ? -delta : delta));
                    const newW = newH * lockedAspectRatio;
                    const centerX = rectStart.x + rectStart.width / 2;
                    rect.width = newW; rect.height = newH; rect.x = centerX - newW / 2;
                    if (fromStart) rect.y = rectStart.y + rectStart.height - newH;
                    // else: rect.y stays at rectStart.y (anchor top edge)
                }
            }
        }

        function handleFreeResize(dx, dy) {
            // For corners (tl, tr, bl, br): check character position
            // For edges (left, right, top, bottom): exact match only
            const isLeft = dragging === 'left' || dragging === 'tl' || dragging === 'bl';
            const isRight = dragging === 'right' || dragging === 'tr' || dragging === 'br';
            const isTop = dragging === 'top' || dragging === 'tl' || dragging === 'tr';
            const isBottom = dragging === 'bottom' || dragging === 'bl' || dragging === 'br';

            if (isRight) rect.width = Math.max(MIN_RECT_SIZE, rectStart.width + dx);
            if (isBottom) rect.height = Math.max(MIN_RECT_SIZE, rectStart.height + dy);
            if (isLeft) { const nw = Math.max(MIN_RECT_SIZE, rectStart.width - dx); rect.x = rectStart.x + rectStart.width - nw; rect.width = nw; }
            if (isTop) { const nh = Math.max(MIN_RECT_SIZE, rectStart.height - dy); rect.y = rectStart.y + rectStart.height - nh; rect.height = nh; }
        }

        window.addEventListener('mouseup', () => { if (dragging) autoSave(); dragging = null; });
        window.addEventListener('resize', () => { if (image) { resizeView(); render(); } });

        // Trackpad pan/zoom: two-finger scroll = pan, pinch = zoom
        container.addEventListener('wheel', e => {
            if (!image) return;
            e.preventDefault();

            const cr = container.getBoundingClientRect();
            const mouseX = e.clientX - cr.left;
            const mouseY = e.clientY - cr.top;

            if (e.ctrlKey) {
                // Pinch-to-zoom (ctrlKey is set by macOS during pinch gestures)
                const zoomFactor = 1 - e.deltaY * 0.01;
                const newZoom = Math.min(Math.max(0.1, viewZoom * zoomFactor), 20);

                // Zoom towards mouse position (relative to container center)
                const displayW = image.width * canvasScale;
                const displayH = image.height * canvasScale;
                const centerX = (cr.width - displayW) / 2;
                const centerY = (cr.height - displayH) / 2;

                // Current position in view space
                const viewX = mouseX - centerX - viewOffset.x;
                const viewY = mouseY - centerY - viewOffset.y;

                // Scale the offset to zoom towards cursor
                const scale = newZoom / viewZoom;
                viewOffset.x += viewX - viewX * scale;
                viewOffset.y += viewY - viewY * scale;
                viewZoom = newZoom;
                updateHandles();
            } else {
                // Two-finger pan
                viewOffset.x -= e.deltaX;
                viewOffset.y -= e.deltaY;
            }
            updateView();
        }, { passive: false });

        // Double-click to reset view
        mainSvg.addEventListener('dblclick', e => {
            if (!image) return;
            viewZoom = 1;
            viewOffset = { x: 0, y: 0 };
            updateHandles();
            updateView();
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', e => {
            if ('12345'.includes(e.key)) {
                pushUndo();
                const modes = { '1': '0', '2': '50', '3': '100', '4': 'tiles', '5': 'solo' };
                viewMode = modes[e.key];
                setBtnGroupValue('opacityBtns', viewMode);
                update();
            } else if (e.key.toLowerCase() === 's') { e.preventDefault(); $('saveBtn').click(); }
            else if (e.key.toLowerCase() === 'g') { e.preventDefault(); $('saveSvgBtn').click(); }
            else if (e.key.toLowerCase() === 'x') { $('expandMode').click(); }
            else if (e.key.toLowerCase() === 'h') {
                pushUndo();
                const modes = ['square', 'hex', 'hexV', 'tri', 'triH'];
                tileMode = modes[(modes.indexOf(tileMode) + 1) % modes.length];
                setBtnGroupValue('tileBtns', tileMode);
                update();
            }
            else if (e.key.toLowerCase() === 'e') { $('eyedropperBtn').click(); }
            else if (e.key.toLowerCase() === 'c') { $('chromaToggle').click(); }
            else if (e.key.toLowerCase() === 'p') { togglePalettePanel(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        loadFromLocalStorage();
    </script>
</body>
</html>
